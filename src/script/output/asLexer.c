/** \file
 *  This C source file was generated by $ANTLR version 3.3 Nov 30, 2010 12:45:30
 *
 *     -  From the grammar source file : D:\\Development\\armybuilder\\src\\armyscript\\as.g
 *     -                            On : 2011-04-25 15:01:08
 *     -                 for the lexer : asLexerLexer *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "asLexer.h"
/* ----------------------------------------- */


/** String literals used by asLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x2B, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x2D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x75, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x63, 0x6C, 0x61, 0x73, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x73, 0x75, 0x70, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x74, 0x68, 0x69, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x6E, 0x65, 0x77,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x61, 0x73, 0x73, 0x65, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x66, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x66, 0x6F, 0x72, 0x65, 0x61, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x77, 0x68, 0x69, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x64, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x73, 0x77, 0x69, 0x74, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x63, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x62, 0x72, 0x65, 0x61, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x69, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x65, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x74, 0x72, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x63, 0x61, 0x74, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x66, 0x69, 0x6E, 0x61, 0x6C, 0x6C, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x74, 0x68, 0x72, 0x6F, 0x77,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x6E, 0x75, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x74, 0x72, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x66, 0x61, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x26, 0x26,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x7C, 0x7C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x2B, 0x2B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x2D, 0x2D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x63, 0x68, 0x61, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x69, 0x6E, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x72, 0x65, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x76, 0x6F, 0x69, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x73, 0x74, 0x61, 0x74, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x66, 0x69, 0x6E, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x73, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 0x69, 0x7A, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x70, 0x75, 0x62, 0x6C, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};




/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pasLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pasLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pasLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pasLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

 
/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER		    
#undef	    RULEMEMO		    
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar)) 
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif
#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE  void	mT__113    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__114    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__115    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__116    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__117    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__118    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__119    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__120    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__121    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__122    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__123    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__124    (pasLexer ctx);
static ANTLR3_INLINE  void	mT__125    (pasLexer ctx);
static ANTLR3_INLINE  void	mPACKAGE    (pasLexer ctx);
static ANTLR3_INLINE  void	mUSE    (pasLexer ctx);
static ANTLR3_INLINE  void	mCLASS    (pasLexer ctx);
static ANTLR3_INLINE  void	mINTRFACE    (pasLexer ctx);
static ANTLR3_INLINE  void	mSUPER    (pasLexer ctx);
static ANTLR3_INLINE  void	mTHIS    (pasLexer ctx);
static ANTLR3_INLINE  void	mEXTENDS    (pasLexer ctx);
static ANTLR3_INLINE  void	mIMPL    (pasLexer ctx);
static ANTLR3_INLINE  void	mNEW    (pasLexer ctx);
static ANTLR3_INLINE  void	mINST_OF    (pasLexer ctx);
static ANTLR3_INLINE  void	mASSERT    (pasLexer ctx);
static ANTLR3_INLINE  void	mFOR    (pasLexer ctx);
static ANTLR3_INLINE  void	mFOREACH    (pasLexer ctx);
static ANTLR3_INLINE  void	mWHILE    (pasLexer ctx);
static ANTLR3_INLINE  void	mDO    (pasLexer ctx);
static ANTLR3_INLINE  void	mSWITCH    (pasLexer ctx);
static ANTLR3_INLINE  void	mCASE    (pasLexer ctx);
static ANTLR3_INLINE  void	mDEFAULT    (pasLexer ctx);
static ANTLR3_INLINE  void	mBREAK    (pasLexer ctx);
static ANTLR3_INLINE  void	mCONTINUE    (pasLexer ctx);
static ANTLR3_INLINE  void	mRETURN    (pasLexer ctx);
static ANTLR3_INLINE  void	mIF    (pasLexer ctx);
static ANTLR3_INLINE  void	mELSE    (pasLexer ctx);
static ANTLR3_INLINE  void	mTRY    (pasLexer ctx);
static ANTLR3_INLINE  void	mCATCH    (pasLexer ctx);
static ANTLR3_INLINE  void	mFINALLY    (pasLexer ctx);
static ANTLR3_INLINE  void	mTHROW    (pasLexer ctx);
static ANTLR3_INLINE  void	mLITNULL    (pasLexer ctx);
static ANTLR3_INLINE  void	mLITTRUE    (pasLexer ctx);
static ANTLR3_INLINE  void	mLITFALSE    (pasLexer ctx);
static ANTLR3_INLINE  void	mAND    (pasLexer ctx);
static ANTLR3_INLINE  void	mOR    (pasLexer ctx);
static ANTLR3_INLINE  void	mMUL    (pasLexer ctx);
static ANTLR3_INLINE  void	mDIV    (pasLexer ctx);
static ANTLR3_INLINE  void	mREM    (pasLexer ctx);
static ANTLR3_INLINE  void	mPLUS    (pasLexer ctx);
static ANTLR3_INLINE  void	mMINUS    (pasLexer ctx);
static ANTLR3_INLINE  void	mBITCOMPL    (pasLexer ctx);
static ANTLR3_INLINE  void	mNOT    (pasLexer ctx);
static ANTLR3_INLINE  void	mBITAND    (pasLexer ctx);
static ANTLR3_INLINE  void	mBITOR    (pasLexer ctx);
static ANTLR3_INLINE  void	mBITXOR    (pasLexer ctx);
static ANTLR3_INLINE  void	mINCR    (pasLexer ctx);
static ANTLR3_INLINE  void	mDECR    (pasLexer ctx);
static ANTLR3_INLINE  void	mEQUAL    (pasLexer ctx);
static ANTLR3_INLINE  void	mUNEQUAL    (pasLexer ctx);
static ANTLR3_INLINE  void	mSEQUAL    (pasLexer ctx);
static ANTLR3_INLINE  void	mSMALLER    (pasLexer ctx);
static ANTLR3_INLINE  void	mGREATER    (pasLexer ctx);
static ANTLR3_INLINE  void	mGEQUAL    (pasLexer ctx);
static ANTLR3_INLINE  void	mSHIFTL    (pasLexer ctx);
static ANTLR3_INLINE  void	mSHIFTR    (pasLexer ctx);
static ANTLR3_INLINE  void	mT_CHAR    (pasLexer ctx);
static ANTLR3_INLINE  void	mT_INT    (pasLexer ctx);
static ANTLR3_INLINE  void	mT_REAL    (pasLexer ctx);
static ANTLR3_INLINE  void	mT_STRING    (pasLexer ctx);
static ANTLR3_INLINE  void	mT_BOOL    (pasLexer ctx);
static ANTLR3_INLINE  void	mT_VOID    (pasLexer ctx);
static ANTLR3_INLINE  void	mSTATIC    (pasLexer ctx);
static ANTLR3_INLINE  void	mFINAL    (pasLexer ctx);
static ANTLR3_INLINE  void	mABSTRACT    (pasLexer ctx);
static ANTLR3_INLINE  void	mNATIVE    (pasLexer ctx);
static ANTLR3_INLINE  void	mSYNC    (pasLexer ctx);
static ANTLR3_INLINE  void	mPUBLIC    (pasLexer ctx);
static ANTLR3_INLINE  void	mPROT    (pasLexer ctx);
static ANTLR3_INLINE  void	mPRIVATE    (pasLexer ctx);
static ANTLR3_INLINE  void	mSEP    (pasLexer ctx);
static ANTLR3_INLINE  void	mID    (pasLexer ctx);
static ANTLR3_INLINE  void	mINT    (pasLexer ctx);
static ANTLR3_INLINE  void	mFLOAT    (pasLexer ctx);
static ANTLR3_INLINE  void	mWHITESPACE    (pasLexer ctx);
static ANTLR3_INLINE  void	mSTRING    (pasLexer ctx);
static ANTLR3_INLINE  void	mCHAR    (pasLexer ctx);
static ANTLR3_INLINE  void	mCOMMENT    (pasLexer ctx);
static ANTLR3_INLINE  void	mLINE_COMMENT    (pasLexer ctx);
static ANTLR3_INLINE  void	mEXPONENT    (pasLexer ctx);
static ANTLR3_INLINE  void	mHEX_DIGIT    (pasLexer ctx);
static ANTLR3_INLINE  void	mESC_SEQ    (pasLexer ctx);
static ANTLR3_INLINE  void	mOCTAL_ESC    (pasLexer ctx);
static ANTLR3_INLINE  void	mUNICODE_ESC    (pasLexer ctx);
static ANTLR3_INLINE  void	mTokens    (pasLexer ctx);
static void	asLexerFree(pasLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
asLexerFree  (pasLexer ctx)
{
    LEXER->free(LEXER);
    
    ANTLR3_FREE(ctx);
}

static void
asLexerReset (pasLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Development\\armybuilder\\src\\armyscript\\as.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called asLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return 
 *     - Success pasLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pasLexer asLexerNew         
(pANTLR3_INPUT_STREAM instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return asLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called asLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return 
 *     - Success pasLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pasLexer asLexerNewSSD         
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pasLexer ctx; // Context structure we will build and return

    ctx = (pasLexer) ANTLR3_CALLOC(1, sizeof(asLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in asLexer.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);
    
    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our asLexer interface
     */
    ctx->mT__113	= mT__113;
    ctx->mT__114	= mT__114;
    ctx->mT__115	= mT__115;
    ctx->mT__116	= mT__116;
    ctx->mT__117	= mT__117;
    ctx->mT__118	= mT__118;
    ctx->mT__119	= mT__119;
    ctx->mT__120	= mT__120;
    ctx->mT__121	= mT__121;
    ctx->mT__122	= mT__122;
    ctx->mT__123	= mT__123;
    ctx->mT__124	= mT__124;
    ctx->mT__125	= mT__125;
    ctx->mPACKAGE	= mPACKAGE;
    ctx->mUSE	= mUSE;
    ctx->mCLASS	= mCLASS;
    ctx->mINTRFACE	= mINTRFACE;
    ctx->mSUPER	= mSUPER;
    ctx->mTHIS	= mTHIS;
    ctx->mEXTENDS	= mEXTENDS;
    ctx->mIMPL	= mIMPL;
    ctx->mNEW	= mNEW;
    ctx->mINST_OF	= mINST_OF;
    ctx->mASSERT	= mASSERT;
    ctx->mFOR	= mFOR;
    ctx->mFOREACH	= mFOREACH;
    ctx->mWHILE	= mWHILE;
    ctx->mDO	= mDO;
    ctx->mSWITCH	= mSWITCH;
    ctx->mCASE	= mCASE;
    ctx->mDEFAULT	= mDEFAULT;
    ctx->mBREAK	= mBREAK;
    ctx->mCONTINUE	= mCONTINUE;
    ctx->mRETURN	= mRETURN;
    ctx->mIF	= mIF;
    ctx->mELSE	= mELSE;
    ctx->mTRY	= mTRY;
    ctx->mCATCH	= mCATCH;
    ctx->mFINALLY	= mFINALLY;
    ctx->mTHROW	= mTHROW;
    ctx->mLITNULL	= mLITNULL;
    ctx->mLITTRUE	= mLITTRUE;
    ctx->mLITFALSE	= mLITFALSE;
    ctx->mAND	= mAND;
    ctx->mOR	= mOR;
    ctx->mMUL	= mMUL;
    ctx->mDIV	= mDIV;
    ctx->mREM	= mREM;
    ctx->mPLUS	= mPLUS;
    ctx->mMINUS	= mMINUS;
    ctx->mBITCOMPL	= mBITCOMPL;
    ctx->mNOT	= mNOT;
    ctx->mBITAND	= mBITAND;
    ctx->mBITOR	= mBITOR;
    ctx->mBITXOR	= mBITXOR;
    ctx->mINCR	= mINCR;
    ctx->mDECR	= mDECR;
    ctx->mEQUAL	= mEQUAL;
    ctx->mUNEQUAL	= mUNEQUAL;
    ctx->mSEQUAL	= mSEQUAL;
    ctx->mSMALLER	= mSMALLER;
    ctx->mGREATER	= mGREATER;
    ctx->mGEQUAL	= mGEQUAL;
    ctx->mSHIFTL	= mSHIFTL;
    ctx->mSHIFTR	= mSHIFTR;
    ctx->mT_CHAR	= mT_CHAR;
    ctx->mT_INT	= mT_INT;
    ctx->mT_REAL	= mT_REAL;
    ctx->mT_STRING	= mT_STRING;
    ctx->mT_BOOL	= mT_BOOL;
    ctx->mT_VOID	= mT_VOID;
    ctx->mSTATIC	= mSTATIC;
    ctx->mFINAL	= mFINAL;
    ctx->mABSTRACT	= mABSTRACT;
    ctx->mNATIVE	= mNATIVE;
    ctx->mSYNC	= mSYNC;
    ctx->mPUBLIC	= mPUBLIC;
    ctx->mPROT	= mPROT;
    ctx->mPRIVATE	= mPRIVATE;
    ctx->mSEP	= mSEP;
    ctx->mID	= mID;
    ctx->mINT	= mINT;
    ctx->mFLOAT	= mFLOAT;
    ctx->mWHITESPACE	= mWHITESPACE;
    ctx->mSTRING	= mSTRING;
    ctx->mCHAR	= mCHAR;
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mLINE_COMMENT	= mLINE_COMMENT;
    ctx->mEXPONENT	= mEXPONENT;
    ctx->mHEX_DIGIT	= mHEX_DIGIT;
    ctx->mESC_SEQ	= mESC_SEQ;
    ctx->mOCTAL_ESC	= mOCTAL_ESC;
    ctx->mUNICODE_ESC	= mUNICODE_ESC;
    ctx->mTokens	= mTokens;
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;
    
    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= asLexerFree;
    ctx->reset          = asLexerReset;

    
    


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    469:1: FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );
 */
static const ANTLR3_INT32 dfa9_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_max[5] =
    {
	57, 101, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa9_special[5] =
    {	
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa9_T_empty	    NULL

static const ANTLR3_INT32 dfa9_T0[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };static const ANTLR3_INT32 dfa9_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa9_transitions[] =
{
    dfa9_T1, dfa9_T0, dfa9_T_empty, dfa9_T_empty, dfa9_T_empty	
};


/* Declare tracking structure for Cyclic DFA 9
 */
static
ANTLR3_CYCLIC_DFA cdfa9
    =	{
	    9,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"469:1: FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa9_eot,	    /* EOT table			    */
	    dfa9_eof,	    /* EOF table			    */
	    dfa9_min,	    /* Minimum tokens for each state    */
	    dfa9_max,	    /* Maximum tokens for each state    */
	    dfa9_accept,	/* Accept table			    */
	    dfa9_special,	/* Special transition states	    */
	    dfa9_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 9
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | PACKAGE | USE | CLASS | INTRFACE | SUPER | THIS | EXTENDS | IMPL | NEW | INST_OF | ASSERT | FOR | FOREACH | WHILE | DO | SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN | IF | ELSE | TRY | CATCH | FINALLY | THROW | LITNULL | LITTRUE | LITFALSE | AND | OR | MUL | DIV | REM | PLUS | MINUS | BITCOMPL | NOT | BITAND | BITOR | BITXOR | INCR | DECR | EQUAL | UNEQUAL | SEQUAL | SMALLER | GREATER | GEQUAL | SHIFTL | SHIFTR | T_CHAR | T_INT | T_REAL | T_STRING | T_BOOL | T_VOID | STATIC | FINAL | ABSTRACT | NATIVE | SYNC | PUBLIC | PROT | PRIVATE | SEP | ID | INT | FLOAT | WHITESPACE | STRING | CHAR | COMMENT | LINE_COMMENT );
 */
static const ANTLR3_INT32 dfa20_eot[304] =
    {
	-1, 45, -1, -1, 48, -1, -1, -1, -1, -1, 51, 54, -1, -1, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 89, 91, -1, 94, -1, -1, 96, -1, 
	99, 102, 40, -1, -1, 104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 118, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 139, 40, 40, 40, 40, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, 40, 40, 40, 
	40, 150, 40, 40, 40, 40, 40, 157, 40, 40, -1, 40, 40, 40, 40, 40, 40, 40, 
	167, 40, 40, 40, 171, 40, 40, 40, 40, 177, 40, 40, 40, -1, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, 40, 192, 40, 40, 195, 40, -1, 40, 40, 40, 
	40, 40, 40, 40, 204, 40, -1, 206, 40, 208, -1, 209, 40, 40, 40, 40, -1, 
	40, 40, 40, 40, 40, 40, 40, 221, 222, 40, 40, 40, 40, 227, -1, 228, 40, 
	-1, 40, 40, 40, 233, 40, 40, 40, 40, -1, 238, -1, 40, -1, -1, 40, 40, 40, 
	40, 245, 246, 247, 40, 249, 40, 40, -1, -1, 40, 253, 40, 40, -1, -1, 40, 
	40, 40, 40, -1, 260, 261, 262, 40, -1, 40, 265, 266, 40, 40, 40, -1, -1, 
	-1, 40, -1, 40, 272, 273, -1, 40, 275, 40, 40, 40, 40, -1, -1, -1, 40, 
	281, -1, -1, 40, 283, 284, 285, 286, -1, -1, 40, -1, 288, 40, 40, 40, 40, 
	-1, 293, -1, -1, -1, -1, 294, -1, 295, 40, 40, 40, -1, -1, -1, 299, 300, 
	40, -1, -1, 40, 303, -1
    };
static const ANTLR3_INT32 dfa20_eof[304] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa20_min[304] =
    {
	9, 48, -1, -1, 61, -1, -1, -1, -1, -1, 43, 45, -1, -1, 97, 115, 97, 102, 
	116, 104, 108, 97, 98, 97, 104, 101, 111, 101, 38, 124, -1, 42, -1, -1, 
	61, -1, 60, 61, 111, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 99, 98, 105, 101, 97, 115, 110, 97, 115, 112, 48, 112, 105, 
	97, 110, 105, 117, 116, 115, 119, 108, 116, 115, 115, 114, 110, 108, 105, 
	48, 102, 101, 111, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 105, -1, 107, 108, 116, 118, 48, 115, 101, 99, 116, 114, 48, 
	116, 108, -1, 101, 116, 105, 116, 99, 115, 111, 48, 101, 101, 101, 48, 
	108, 105, 101, 116, 48, 97, 115, 108, -1, 97, 97, 108, 117, 108, 100, 97, 
	105, 101, 97, -1, 115, 48, 104, 105, 48, 114, -1, 97, 101, 114, 99, 110, 
	105, 104, 48, 119, -1, 48, 110, 48, -1, 48, 118, 114, 114, 97, -1, 108, 
	101, 101, 117, 107, 101, 114, 48, 48, 103, 99, 99, 116, 48, -1, 48, 110, 
	-1, 102, 110, 109, 48, 104, 103, 99, 114, -1, 48, -1, 100, -1, -1, 101, 
	116, 97, 99, 48, 48, 48, 108, 48, 97, 110, -1, -1, 101, 48, 116, 101, -1, 
	-1, 117, 97, 99, 101, -1, 48, 48, 48, 111, -1, 115, 48, 48, 99, 104, 121, 
	-1, -1, -1, 116, -1, 110, 48, 48, -1, 101, 48, 101, 99, 101, 110, -1, -1, 
	-1, 110, 48, -1, -1, 116, 48, 48, 48, 48, -1, -1, 100, -1, 48, 101, 111, 
	116, 105, -1, 48, -1, -1, -1, -1, 48, -1, 48, 102, 115, 122, -1, -1, -1, 
	48, 48, 101, -1, -1, 100, 48, -1
    };
static const ANTLR3_INT32 dfa20_max[304] =
    {
	126, 57, -1, -1, 61, -1, -1, -1, -1, -1, 61, 61, -1, -1, 117, 115, 111, 
	110, 121, 114, 120, 117, 115, 111, 104, 111, 114, 101, 38, 124, -1, 47, 
	-1, -1, 61, -1, 61, 62, 111, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 99, 98, 111, 101, 97, 116, 110, 97, 116, 112, 122, 
	112, 105, 114, 110, 114, 121, 116, 115, 119, 108, 116, 115, 115, 114, 110, 
	108, 105, 122, 102, 101, 111, 116, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 105, -1, 107, 108, 116, 118, 122, 115, 101, 99, 
	116, 114, 122, 116, 108, -1, 101, 116, 105, 116, 99, 115, 111, 122, 101, 
	101, 101, 122, 108, 105, 101, 116, 122, 97, 115, 108, -1, 97, 97, 108, 
	117, 108, 100, 97, 105, 101, 97, -1, 115, 122, 104, 105, 122, 114, -1, 
	97, 101, 114, 99, 110, 105, 104, 122, 119, -1, 122, 110, 122, -1, 122, 
	118, 114, 114, 97, -1, 108, 101, 101, 117, 107, 101, 114, 122, 122, 103, 
	99, 99, 116, 122, -1, 122, 110, -1, 102, 110, 109, 122, 104, 103, 99, 114, 
	-1, 122, -1, 100, -1, -1, 101, 116, 97, 99, 122, 122, 122, 108, 122, 97, 
	110, -1, -1, 101, 122, 116, 101, -1, -1, 117, 97, 99, 101, -1, 122, 122, 
	122, 111, -1, 115, 122, 122, 99, 104, 121, -1, -1, -1, 116, -1, 110, 122, 
	122, -1, 101, 122, 101, 99, 101, 110, -1, -1, -1, 110, 122, -1, -1, 116, 
	122, 122, 122, 122, -1, -1, 100, -1, 122, 101, 111, 116, 105, -1, 122, 
	-1, -1, -1, -1, 122, -1, 122, 102, 115, 122, -1, -1, -1, 122, 122, 101, 
	-1, -1, 100, 122, -1
    };
static const ANTLR3_INT32 dfa20_accept[304] =
    {
	-1, -1, 2, 3, -1, 5, 6, 7, 8, 9, -1, -1, 12, 13, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 46, -1, 48, 51, -1, 55, -1, -1, 
	-1, 80, 81, -1, 84, 85, 86, 1, 83, 58, 4, 10, 56, 49, 11, 57, 50, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 44, 53, 45, 54, 87, 
	88, 47, 59, 52, 60, 64, 61, 63, 65, 62, -1, 82, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 35, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 15, -1, -1, -1, -1, -1, -1, 67, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 37, -1, -1, -1, 22, -1, -1, -1, -1, -1, 25, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 30, -1, -1, 66, -1, -1, -1, -1, -1, 
	-1, -1, -1, 19, -1, 42, -1, 36, 41, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 68, 71, -1, -1, -1, -1, 16, 38, -1, -1, -1, -1, 18, -1, -1, -1, 
	-1, 40, -1, -1, -1, -1, -1, -1, 73, 43, 27, -1, 32, -1, -1, -1, 77, -1, 
	-1, -1, -1, -1, -1, 29, 69, 72, -1, -1, 75, 24, -1, -1, -1, -1, -1, 34, 
	14, -1, 79, -1, -1, -1, -1, -1, 20, -1, 26, 39, 31, 70, -1, 33, -1, -1, 
	-1, -1, 74, 78, 17, -1, -1, -1, 23, 21, -1, -1, 76
    };
static const ANTLR3_INT32 dfa20_special[304] =
    {	
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa20_T_empty	    NULL

static const ANTLR3_INT32 dfa20_T0[] =
    {
	241
    };static const ANTLR3_INT32 dfa20_T1[] =
    {
	86, -1, -1, 85
    };static const ANTLR3_INT32 dfa20_T2[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };static const ANTLR3_INT32 dfa20_T3[] =
    {
	174
    };static const ANTLR3_INT32 dfa20_T4[] =
    {
	211
    };static const ANTLR3_INT32 dfa20_T5[] =
    {
	87
    };static const ANTLR3_INT32 dfa20_T6[] =
    {
	127, -1, -1, -1, 126
    };static const ANTLR3_INT32 dfa20_T7[] =
    {
	290
    };static const ANTLR3_INT32 dfa20_T8[] =
    {
	296
    };static const ANTLR3_INT32 dfa20_T9[] =
    {
	133
    };static const ANTLR3_INT32 dfa20_T10[] =
    {
	158
    };static const ANTLR3_INT32 dfa20_T11[] =
    {
	278
    };static const ANTLR3_INT32 dfa20_T12[] =
    {
	258
    };static const ANTLR3_INT32 dfa20_T13[] =
    {
	231
    };static const ANTLR3_INT32 dfa20_T14[] =
    {
	197
    };static const ANTLR3_INT32 dfa20_T15[] =
    {
	108, -1, -1, -1, -1, -1, 107
    };static const ANTLR3_INT32 dfa20_T16[] =
    {
	130
    };static const ANTLR3_INT32 dfa20_T17[] =
    {
	120
    };static const ANTLR3_INT32 dfa20_T18[] =
    {
	161
    };static const ANTLR3_INT32 dfa20_T19[] =
    {
	200
    };static const ANTLR3_INT32 dfa20_T20[] =
    {
	138
    };static const ANTLR3_INT32 dfa20_T21[] =
    {
	70, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71
    };static const ANTLR3_INT32 dfa20_T22[] =
    {
	180
    };static const ANTLR3_INT32 dfa20_T23[] =
    {
	216
    };static const ANTLR3_INT32 dfa20_T24[] =
    {
	243
    };static const ANTLR3_INT32 dfa20_T25[] =
    {
	213
    };static const ANTLR3_INT32 dfa20_T26[] =
    {
	268
    };static const ANTLR3_INT32 dfa20_T27[] =
    {
	119
    };static const ANTLR3_INT32 dfa20_T28[] =
    {
	160
    };static const ANTLR3_INT32 dfa20_T29[] =
    {
	289
    };static const ANTLR3_INT32 dfa20_T30[] =
    {
	257
    };static const ANTLR3_INT32 dfa20_T31[] =
    {
	277
    };static const ANTLR3_INT32 dfa20_T32[] =
    {
	196
    };static const ANTLR3_INT32 dfa20_T33[] =
    {
	230
    };static const ANTLR3_INT32 dfa20_T34[] =
    {
	191
    };static const ANTLR3_INT32 dfa20_T35[] =
    {
	151
    };static const ANTLR3_INT32 dfa20_T36[] =
    {
	110
    };static const ANTLR3_INT32 dfa20_T37[] =
    {
	53, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 52
    };static const ANTLR3_INT32 dfa20_T38[] =
    {
	109
    };static const ANTLR3_INT32 dfa20_T39[] =
    {
	279
    };static const ANTLR3_INT32 dfa20_T40[] =
    {
	291
    };static const ANTLR3_INT32 dfa20_T41[] =
    {
	78, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77
    };static const ANTLR3_INT32 dfa20_T42[] =
    {
	297
    };static const ANTLR3_INT32 dfa20_T43[] =
    {
	159
    };static const ANTLR3_INT32 dfa20_T44[] =
    {
	198
    };static const ANTLR3_INT32 dfa20_T45[] =
    {
	232
    };static const ANTLR3_INT32 dfa20_T46[] =
    {
	259
    };static const ANTLR3_INT32 dfa20_T47[] =
    {
	117
    };static const ANTLR3_INT32 dfa20_T48[] =
    {
	239
    };static const ANTLR3_INT32 dfa20_T49[] =
    {
	264
    };static const ANTLR3_INT32 dfa20_T50[] =
    {
	50, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	49
    };static const ANTLR3_INT32 dfa20_T51[] =
    {
	128
    };static const ANTLR3_INT32 dfa20_T52[] =
    {
	207
    };static const ANTLR3_INT32 dfa20_T53[] =
    {
	169
    };static const ANTLR3_INT32 dfa20_T54[] =
    {
	165
    };static const ANTLR3_INT32 dfa20_T55[] =
    {
	199
    };static const ANTLR3_INT32 dfa20_T56[] =
    {
	269
    };static const ANTLR3_INT32 dfa20_T57[] =
    {
	205
    };static const ANTLR3_INT32 dfa20_T58[] =
    {
	166
    };static const ANTLR3_INT32 dfa20_T59[] =
    {
	131
    };static const ANTLR3_INT32 dfa20_T60[] =
    {
	153
    };static const ANTLR3_INT32 dfa20_T61[] =
    {
	193
    };static const ANTLR3_INT32 dfa20_T62[] =
    {
	172
    };static const ANTLR3_INT32 dfa20_T63[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 244, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };static const ANTLR3_INT32 dfa20_T64[] =
    {
	81, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, 79
    };static const ANTLR3_INT32 dfa20_T65[] =
    {
	168
    };static const ANTLR3_INT32 dfa20_T66[] =
    {
	137
    };static const ANTLR3_INT32 dfa20_T67[] =
    {
	179
    };static const ANTLR3_INT32 dfa20_T68[] =
    {
	215
    };static const ANTLR3_INT32 dfa20_T69[] =
    {
	141
    };static const ANTLR3_INT32 dfa20_T70[] =
    {
	82
    };static const ANTLR3_INT32 dfa20_T71[] =
    {
	270
    };static const ANTLR3_INT32 dfa20_T72[] =
    {
	248
    };static const ANTLR3_INT32 dfa20_T73[] =
    {
	113
    };static const ANTLR3_INT32 dfa20_T74[] =
    {
	218
    };static const ANTLR3_INT32 dfa20_T75[] =
    {
	182
    };static const ANTLR3_INT32 dfa20_T76[] =
    {
	152
    };static const ANTLR3_INT32 dfa20_T77[] =
    {
	234
    };static const ANTLR3_INT32 dfa20_T78[] =
    {
	181
    };static const ANTLR3_INT32 dfa20_T79[] =
    {
	217
    };static const ANTLR3_INT32 dfa20_T80[] =
    {
	140
    };static const ANTLR3_INT32 dfa20_T81[] =
    {
	111, 112
    };static const ANTLR3_INT32 dfa20_T82[] =
    {
	170
    };static const ANTLR3_INT32 dfa20_T83[] =
    {
	129
    };static const ANTLR3_INT32 dfa20_T84[] =
    {
	276
    };static const ANTLR3_INT32 dfa20_T85[] =
    {
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 57, 
	-1, -1, 56
    };static const ANTLR3_INT32 dfa20_T86[] =
    {
	46, 46, 46, 46, 46, 46, 46, 46, 46, 46
    };static const ANTLR3_INT32 dfa20_T87[] =
    {
	154
    };static const ANTLR3_INT32 dfa20_T88[] =
    {
	194
    };static const ANTLR3_INT32 dfa20_T89[] =
    {
	229
    };static const ANTLR3_INT32 dfa20_T90[] =
    {
	256
    };static const ANTLR3_INT32 dfa20_T91[] =
    {
	220
    };static const ANTLR3_INT32 dfa20_T92[] =
    {
	251
    };static const ANTLR3_INT32 dfa20_T93[] =
    {
	46, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 46
    };static const ANTLR3_INT32 dfa20_T94[] =
    {
	184
    };static const ANTLR3_INT32 dfa20_T95[] =
    {
	90
    };static const ANTLR3_INT32 dfa20_T96[] =
    {
	188
    };static const ANTLR3_INT32 dfa20_T97[] =
    {
	147
    };static const ANTLR3_INT32 dfa20_T98[] =
    {
	106
    };static const ANTLR3_INT32 dfa20_T99[] =
    {
	280
    };static const ANTLR3_INT32 dfa20_T100[] =
    {
	263
    };static const ANTLR3_INT32 dfa20_T101[] =
    {
	92, -1, -1, -1, -1, 93
    };static const ANTLR3_INT32 dfa20_T102[] =
    {
	237
    };static const ANTLR3_INT32 dfa20_T103[] =
    {
	203
    };static const ANTLR3_INT32 dfa20_T104[] =
    {
	302
    };static const ANTLR3_INT32 dfa20_T105[] =
    {
	301
    };static const ANTLR3_INT32 dfa20_T106[] =
    {
	298
    };static const ANTLR3_INT32 dfa20_T107[] =
    {
	292
    };static const ANTLR3_INT32 dfa20_T108[] =
    {
	240
    };static const ANTLR3_INT32 dfa20_T109[] =
    {
	123
    };static const ANTLR3_INT32 dfa20_T110[] =
    {
	164
    };static const ANTLR3_INT32 dfa20_T111[] =
    {
	173
    };static const ANTLR3_INT32 dfa20_T112[] =
    {
	210
    };static const ANTLR3_INT32 dfa20_T113[] =
    {
	132
    };static const ANTLR3_INT32 dfa20_T114[] =
    {
	76, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 75
    };static const ANTLR3_INT32 dfa20_T115[] =
    {
	175
    };static const ANTLR3_INT32 dfa20_T116[] =
    {
	134
    };static const ANTLR3_INT32 dfa20_T117[] =
    {
	242
    };static const ANTLR3_INT32 dfa20_T118[] =
    {
	212
    };static const ANTLR3_INT32 dfa20_T119[] =
    {
	282
    };static const ANTLR3_INT32 dfa20_T120[] =
    {
	267
    };static const ANTLR3_INT32 dfa20_T121[] =
    {
	116, 115
    };static const ANTLR3_INT32 dfa20_T122[] =
    {
	95
    };static const ANTLR3_INT32 dfa20_T123[] =
    {
	163
    };static const ANTLR3_INT32 dfa20_T124[] =
    {
	202
    };static const ANTLR3_INT32 dfa20_T125[] =
    {
	236
    };static const ANTLR3_INT32 dfa20_T126[] =
    {
	65, -1, -1, -1, -1, -1, -1, 64, 63
    };static const ANTLR3_INT32 dfa20_T127[] =
    {
	145
    };static const ANTLR3_INT32 dfa20_T128[] =
    {
	186
    };static const ANTLR3_INT32 dfa20_T129[] =
    {
	124, -1, -1, -1, -1, -1, -1, -1, -1, 125
    };static const ANTLR3_INT32 dfa20_T130[] =
    {
	73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72
    };static const ANTLR3_INT32 dfa20_T131[] =
    {
	58
    };static const ANTLR3_INT32 dfa20_T132[] =
    {
	122, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 121
    };static const ANTLR3_INT32 dfa20_T133[] =
    {
	226
    };static const ANTLR3_INT32 dfa20_T134[] =
    {
	190
    };static const ANTLR3_INT32 dfa20_T135[] =
    {
	255
    };static const ANTLR3_INT32 dfa20_T136[] =
    {
	84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83
    };static const ANTLR3_INT32 dfa20_T137[] =
    {
	149
    };static const ANTLR3_INT32 dfa20_T138[] =
    {
	287
    };static const ANTLR3_INT32 dfa20_T139[] =
    {
	189
    };static const ANTLR3_INT32 dfa20_T140[] =
    {
	88
    };static const ANTLR3_INT32 dfa20_T141[] =
    {
	225
    };static const ANTLR3_INT32 dfa20_T142[] =
    {
	254
    };static const ANTLR3_INT32 dfa20_T143[] =
    {
	274
    };static const ANTLR3_INT32 dfa20_T144[] =
    {
	148
    };static const ANTLR3_INT32 dfa20_T145[] =
    {
	224
    };static const ANTLR3_INT32 dfa20_T146[] =
    {
	135
    };static const ANTLR3_INT32 dfa20_T147[] =
    {
	98, 97
    };static const ANTLR3_INT32 dfa20_T148[] =
    {
	60, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 59, -1, -1, 61
    };static const ANTLR3_INT32 dfa20_T149[] =
    {
	144, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 143
    };static const ANTLR3_INT32 dfa20_T150[] =
    {
	146
    };static const ANTLR3_INT32 dfa20_T151[] =
    {
	105
    };static const ANTLR3_INT32 dfa20_T152[] =
    {
	47
    };static const ANTLR3_INT32 dfa20_T153[] =
    {
	252
    };static const ANTLR3_INT32 dfa20_T154[] =
    {
	223
    };static const ANTLR3_INT32 dfa20_T155[] =
    {
	187
    };static const ANTLR3_INT32 dfa20_T156[] =
    {
	235
    };static const ANTLR3_INT32 dfa20_T157[] =
    {
	162
    };static const ANTLR3_INT32 dfa20_T158[] =
    {
	201
    };static const ANTLR3_INT32 dfa20_T159[] =
    {
	271
    };static const ANTLR3_INT32 dfa20_T160[] =
    {
	136
    };static const ANTLR3_INT32 dfa20_T161[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 176, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };static const ANTLR3_INT32 dfa20_T162[] =
    {
	178
    };static const ANTLR3_INT32 dfa20_T163[] =
    {
	219
    };static const ANTLR3_INT32 dfa20_T164[] =
    {
	250
    };static const ANTLR3_INT32 dfa20_T165[] =
    {
	142
    };static const ANTLR3_INT32 dfa20_T166[] =
    {
	214
    };static const ANTLR3_INT32 dfa20_T167[] =
    {
	183
    };static const ANTLR3_INT32 dfa20_T168[] =
    {
	185
    };static const ANTLR3_INT32 dfa20_T169[] =
    {
	103
    };static const ANTLR3_INT32 dfa20_T170[] =
    {
	42, 42, -1, 42, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 42, 34, 43, -1, -1, 32, 28, 44, 6, 7, 30, 10, 5, 11, 
	1, 31, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 9, 39, 36, 4, 37, -1, 8, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 12, -1, 13, 35, 40, -1, 22, 26, 16, 25, 
	20, 23, 40, 40, 17, 40, 40, 40, 40, 21, 40, 14, 40, 27, 18, 19, 15, 38, 
	24, 40, 40, 40, 2, 29, 3, 33
    };static const ANTLR3_INT32 dfa20_T171[] =
    {
	100, 101
    };static const ANTLR3_INT32 dfa20_T172[] =
    {
	155
    };static const ANTLR3_INT32 dfa20_T173[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 156, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };static const ANTLR3_INT32 dfa20_T174[] =
    {
	114
    };static const ANTLR3_INT32 dfa20_T175[] =
    {
	68, 66, -1, 67, -1, 69
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa20_transitions[] =
{
    dfa20_T170, dfa20_T86, dfa20_T_empty, dfa20_T_empty, dfa20_T152, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T50, 
    dfa20_T37, dfa20_T_empty, dfa20_T_empty, dfa20_T85, dfa20_T131, dfa20_T148, 
    dfa20_T126, dfa20_T175, dfa20_T21, dfa20_T130, dfa20_T114, dfa20_T41, 
    dfa20_T64, dfa20_T70, dfa20_T136, dfa20_T1, dfa20_T5, dfa20_T140, dfa20_T95, 
    dfa20_T_empty, dfa20_T101, dfa20_T_empty, dfa20_T_empty, dfa20_T122, 
    dfa20_T_empty, dfa20_T147, dfa20_T171, dfa20_T169, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T93, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T151, 
    dfa20_T98, dfa20_T15, dfa20_T38, dfa20_T36, dfa20_T81, dfa20_T73, dfa20_T174, 
    dfa20_T121, dfa20_T47, dfa20_T2, dfa20_T27, dfa20_T17, dfa20_T132, dfa20_T109, 
    dfa20_T129, dfa20_T6, dfa20_T51, dfa20_T83, dfa20_T16, dfa20_T59, dfa20_T113, 
    dfa20_T9, dfa20_T116, dfa20_T146, dfa20_T160, dfa20_T66, dfa20_T20, 
    dfa20_T2, dfa20_T80, dfa20_T69, dfa20_T165, dfa20_T149, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T127, 
    dfa20_T_empty, dfa20_T150, dfa20_T97, dfa20_T144, dfa20_T137, dfa20_T2, 
    dfa20_T35, dfa20_T76, dfa20_T60, dfa20_T87, dfa20_T172, dfa20_T173, 
    dfa20_T10, dfa20_T43, dfa20_T_empty, dfa20_T28, dfa20_T18, dfa20_T157, 
    dfa20_T123, dfa20_T110, dfa20_T54, dfa20_T58, dfa20_T2, dfa20_T65, dfa20_T53, 
    dfa20_T82, dfa20_T2, dfa20_T62, dfa20_T111, dfa20_T3, dfa20_T115, dfa20_T161, 
    dfa20_T162, dfa20_T67, dfa20_T22, dfa20_T_empty, dfa20_T78, dfa20_T75, 
    dfa20_T167, dfa20_T94, dfa20_T168, dfa20_T128, dfa20_T155, dfa20_T96, 
    dfa20_T139, dfa20_T134, dfa20_T_empty, dfa20_T34, dfa20_T2, dfa20_T61, 
    dfa20_T88, dfa20_T2, dfa20_T32, dfa20_T_empty, dfa20_T14, dfa20_T44, 
    dfa20_T55, dfa20_T19, dfa20_T158, dfa20_T124, dfa20_T103, dfa20_T2, 
    dfa20_T57, dfa20_T_empty, dfa20_T2, dfa20_T52, dfa20_T2, dfa20_T_empty, 
    dfa20_T2, dfa20_T112, dfa20_T4, dfa20_T118, dfa20_T25, dfa20_T_empty, 
    dfa20_T166, dfa20_T68, dfa20_T23, dfa20_T79, dfa20_T74, dfa20_T163, 
    dfa20_T91, dfa20_T2, dfa20_T2, dfa20_T154, dfa20_T145, dfa20_T141, dfa20_T133, 
    dfa20_T2, dfa20_T_empty, dfa20_T2, dfa20_T89, dfa20_T_empty, dfa20_T33, 
    dfa20_T13, dfa20_T45, dfa20_T2, dfa20_T77, dfa20_T156, dfa20_T125, dfa20_T102, 
    dfa20_T_empty, dfa20_T2, dfa20_T_empty, dfa20_T48, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T108, dfa20_T0, dfa20_T117, dfa20_T24, dfa20_T63, dfa20_T2, dfa20_T2, 
    dfa20_T72, dfa20_T2, dfa20_T164, dfa20_T92, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T153, dfa20_T2, dfa20_T142, dfa20_T135, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T90, dfa20_T30, dfa20_T12, dfa20_T46, dfa20_T_empty, dfa20_T2, 
    dfa20_T2, dfa20_T2, dfa20_T100, dfa20_T_empty, dfa20_T49, dfa20_T2, 
    dfa20_T2, dfa20_T120, dfa20_T26, dfa20_T56, dfa20_T_empty, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T71, dfa20_T_empty, dfa20_T159, dfa20_T2, dfa20_T2, 
    dfa20_T_empty, dfa20_T143, dfa20_T2, dfa20_T84, dfa20_T31, dfa20_T11, 
    dfa20_T39, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T99, dfa20_T2, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T119, dfa20_T2, dfa20_T2, dfa20_T2, 
    dfa20_T2, dfa20_T_empty, dfa20_T_empty, dfa20_T138, dfa20_T_empty, dfa20_T2, 
    dfa20_T29, dfa20_T7, dfa20_T40, dfa20_T107, dfa20_T_empty, dfa20_T2, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T_empty, dfa20_T2, 
    dfa20_T_empty, dfa20_T2, dfa20_T8, dfa20_T42, dfa20_T106, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T_empty, dfa20_T2, dfa20_T2, dfa20_T105, dfa20_T_empty, 
    dfa20_T_empty, dfa20_T104, dfa20_T2, dfa20_T_empty	
};


/* Declare tracking structure for Cyclic DFA 20
 */
static
ANTLR3_CYCLIC_DFA cdfa20
    =	{
	    20,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | PACKAGE | USE | CLASS | INTRFACE | SUPER | THIS | EXTENDS | IMPL | NEW | INST_OF | ASSERT | FOR | FOREACH | WHILE | DO | SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN | IF | ELSE | TRY | CATCH | FINALLY | THROW | LITNULL | LITTRUE | LITFALSE | AND | OR | MUL | DIV | REM | PLUS | MINUS | BITCOMPL | NOT | BITAND | BITOR | BITXOR | INCR | DECR | EQUAL | UNEQUAL | SEQUAL | SMALLER | GREATER | GEQUAL | SHIFTL | SHIFTR | T_CHAR | T_INT | T_REAL | T_STRING | T_BOOL | T_VOID | STATIC | FINAL | ABSTRACT | NATIVE | SYNC | PUBLIC | PROT | PRIVATE | SEP | ID | INT | FLOAT | WHITESPACE | STRING | CHAR | COMMENT | LINE_COMMENT );",	
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa20_eot,	    /* EOT table			    */
	    dfa20_eof,	    /* EOF table			    */
	    dfa20_min,	    /* Minimum tokens for each state    */
	    dfa20_max,	    /* Maximum tokens for each state    */
	    dfa20_accept,	/* Accept table			    */
	    dfa20_special,	/* Special transition states	    */
	    dfa20_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA 20
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */ 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:8: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__113
 *
 * Looks to match the characters the constitute the token T__113
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__113(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__113;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:7:8: ( '.' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:7:10: '.'
    {
        MATCHC('.'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__113Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__113Ex; /* Prevent compiler warnings */
    ruleT__113Ex: ;

}
// $ANTLR end T__113

//   Comes from: 8:8: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__114
 *
 * Looks to match the characters the constitute the token T__114
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__114(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__114;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:8:8: ( '{' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:8:10: '{'
    {
        MATCHC('{'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__114Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__114Ex; /* Prevent compiler warnings */
    ruleT__114Ex: ;

}
// $ANTLR end T__114

//   Comes from: 9:8: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__115
 *
 * Looks to match the characters the constitute the token T__115
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__115(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__115;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:9:8: ( '}' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:9:10: '}'
    {
        MATCHC('}'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__115Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__115Ex; /* Prevent compiler warnings */
    ruleT__115Ex: ;

}
// $ANTLR end T__115

//   Comes from: 10:8: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__116
 *
 * Looks to match the characters the constitute the token T__116
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__116(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__116;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:10:8: ( '=' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:10:10: '='
    {
        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleT__116Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__116Ex; /* Prevent compiler warnings */
    ruleT__116Ex: ;

}
// $ANTLR end T__116

//   Comes from: 11:8: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__117
 *
 * Looks to match the characters the constitute the token T__117
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__117(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__117;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:11:8: ( ',' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:11:10: ','
    {
        MATCHC(','); 
        if  (HASEXCEPTION())
        {
            goto ruleT__117Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__117Ex; /* Prevent compiler warnings */
    ruleT__117Ex: ;

}
// $ANTLR end T__117

//   Comes from: 12:8: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__118
 *
 * Looks to match the characters the constitute the token T__118
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__118(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__118;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:12:8: ( '(' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:12:10: '('
    {
        MATCHC('('); 
        if  (HASEXCEPTION())
        {
            goto ruleT__118Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__118Ex; /* Prevent compiler warnings */
    ruleT__118Ex: ;

}
// $ANTLR end T__118

//   Comes from: 13:8: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__119
 *
 * Looks to match the characters the constitute the token T__119
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__119(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__119;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:13:8: ( ')' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:13:10: ')'
    {
        MATCHC(')'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__119Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__119Ex; /* Prevent compiler warnings */
    ruleT__119Ex: ;

}
// $ANTLR end T__119

//   Comes from: 14:8: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__120
 *
 * Looks to match the characters the constitute the token T__120
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__120(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__120;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:14:8: ( '@' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:14:10: '@'
    {
        MATCHC('@'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__120Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__120Ex; /* Prevent compiler warnings */
    ruleT__120Ex: ;

}
// $ANTLR end T__120

//   Comes from: 15:8: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__121
 *
 * Looks to match the characters the constitute the token T__121
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__121(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__121;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:15:8: ( ':' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:15:10: ':'
    {
        MATCHC(':'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__121Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__121Ex; /* Prevent compiler warnings */
    ruleT__121Ex: ;

}
// $ANTLR end T__121

//   Comes from: 16:8: ( '+=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__122
 *
 * Looks to match the characters the constitute the token T__122
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__122(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__122;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:16:8: ( '+=' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:16:10: '+='
    {
        MATCHS(lit_1); 
        if  (HASEXCEPTION())
        {
            goto ruleT__122Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__122Ex; /* Prevent compiler warnings */
    ruleT__122Ex: ;

}
// $ANTLR end T__122

//   Comes from: 17:8: ( '-=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__123
 *
 * Looks to match the characters the constitute the token T__123
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__123(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__123;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:17:8: ( '-=' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:17:10: '-='
    {
        MATCHS(lit_2); 
        if  (HASEXCEPTION())
        {
            goto ruleT__123Ex;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__123Ex; /* Prevent compiler warnings */
    ruleT__123Ex: ;

}
// $ANTLR end T__123

//   Comes from: 18:8: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__124
 *
 * Looks to match the characters the constitute the token T__124
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__124(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__124;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:18:8: ( '[' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:18:10: '['
    {
        MATCHC('['); 
        if  (HASEXCEPTION())
        {
            goto ruleT__124Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__124Ex; /* Prevent compiler warnings */
    ruleT__124Ex: ;

}
// $ANTLR end T__124

//   Comes from: 19:8: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__125
 *
 * Looks to match the characters the constitute the token T__125
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__125(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__125;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:19:8: ( ']' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:19:10: ']'
    {
        MATCHC(']'); 
        if  (HASEXCEPTION())
        {
            goto ruleT__125Ex;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT__125Ex; /* Prevent compiler warnings */
    ruleT__125Ex: ;

}
// $ANTLR end T__125

//   Comes from: 390:9: ( 'package' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PACKAGE
 *
 * Looks to match the characters the constitute the token PACKAGE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPACKAGE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PACKAGE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:390:9: ( 'package' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:390:11: 'package'
    {
        MATCHS(lit_3); 
        if  (HASEXCEPTION())
        {
            goto rulePACKAGEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePACKAGEEx; /* Prevent compiler warnings */
    rulePACKAGEEx: ;

}
// $ANTLR end PACKAGE

//   Comes from: 391:5: ( 'use' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start USE
 *
 * Looks to match the characters the constitute the token USE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUSE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = USE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:391:5: ( 'use' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:391:7: 'use'
    {
        MATCHS(lit_4); 
        if  (HASEXCEPTION())
        {
            goto ruleUSEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUSEEx; /* Prevent compiler warnings */
    ruleUSEEx: ;

}
// $ANTLR end USE

//   Comes from: 392:7: ( 'class' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLASS
 *
 * Looks to match the characters the constitute the token CLASS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCLASS(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CLASS;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:392:7: ( 'class' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:392:9: 'class'
    {
        MATCHS(lit_5); 
        if  (HASEXCEPTION())
        {
            goto ruleCLASSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCLASSEx; /* Prevent compiler warnings */
    ruleCLASSEx: ;

}
// $ANTLR end CLASS

//   Comes from: 393:9: ( 'interface' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTRFACE
 *
 * Looks to match the characters the constitute the token INTRFACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTRFACE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INTRFACE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:393:9: ( 'interface' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:393:11: 'interface'
    {
        MATCHS(lit_6); 
        if  (HASEXCEPTION())
        {
            goto ruleINTRFACEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINTRFACEEx; /* Prevent compiler warnings */
    ruleINTRFACEEx: ;

}
// $ANTLR end INTRFACE

//   Comes from: 394:7: ( 'super' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SUPER
 *
 * Looks to match the characters the constitute the token SUPER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSUPER(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SUPER;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:394:7: ( 'super' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:394:9: 'super'
    {
        MATCHS(lit_7); 
        if  (HASEXCEPTION())
        {
            goto ruleSUPEREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSUPEREx; /* Prevent compiler warnings */
    ruleSUPEREx: ;

}
// $ANTLR end SUPER

//   Comes from: 395:6: ( 'this' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THIS
 *
 * Looks to match the characters the constitute the token THIS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHIS(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = THIS;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:395:6: ( 'this' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:395:8: 'this'
    {
        MATCHS(lit_8); 
        if  (HASEXCEPTION())
        {
            goto ruleTHISEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTHISEx; /* Prevent compiler warnings */
    ruleTHISEx: ;

}
// $ANTLR end THIS

//   Comes from: 396:9: ( 'extends' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTENDS
 *
 * Looks to match the characters the constitute the token EXTENDS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTENDS(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTENDS;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:396:9: ( 'extends' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:396:11: 'extends'
    {
        MATCHS(lit_9); 
        if  (HASEXCEPTION())
        {
            goto ruleEXTENDSEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEXTENDSEx; /* Prevent compiler warnings */
    ruleEXTENDSEx: ;

}
// $ANTLR end EXTENDS

//   Comes from: 397:6: ( 'implements' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IMPL
 *
 * Looks to match the characters the constitute the token IMPL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIMPL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IMPL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:397:6: ( 'implements' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:397:8: 'implements'
    {
        MATCHS(lit_10); 
        if  (HASEXCEPTION())
        {
            goto ruleIMPLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIMPLEx; /* Prevent compiler warnings */
    ruleIMPLEx: ;

}
// $ANTLR end IMPL

//   Comes from: 398:5: ( 'new' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEW
 *
 * Looks to match the characters the constitute the token NEW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNEW(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NEW;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:398:5: ( 'new' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:398:7: 'new'
    {
        MATCHS(lit_11); 
        if  (HASEXCEPTION())
        {
            goto ruleNEWEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNEWEx; /* Prevent compiler warnings */
    ruleNEWEx: ;

}
// $ANTLR end NEW

//   Comes from: 399:9: ( 'instanceof' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INST_OF
 *
 * Looks to match the characters the constitute the token INST_OF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINST_OF(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INST_OF;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:399:9: ( 'instanceof' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:399:11: 'instanceof'
    {
        MATCHS(lit_12); 
        if  (HASEXCEPTION())
        {
            goto ruleINST_OFEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINST_OFEx; /* Prevent compiler warnings */
    ruleINST_OFEx: ;

}
// $ANTLR end INST_OF

//   Comes from: 400:8: ( 'assert' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ASSERT
 *
 * Looks to match the characters the constitute the token ASSERT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mASSERT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ASSERT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:400:8: ( 'assert' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:400:10: 'assert'
    {
        MATCHS(lit_13); 
        if  (HASEXCEPTION())
        {
            goto ruleASSERTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleASSERTEx; /* Prevent compiler warnings */
    ruleASSERTEx: ;

}
// $ANTLR end ASSERT

//   Comes from: 401:5: ( 'for' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOR
 *
 * Looks to match the characters the constitute the token FOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFOR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FOR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:401:5: ( 'for' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:401:7: 'for'
    {
        MATCHS(lit_14); 
        if  (HASEXCEPTION())
        {
            goto ruleFOREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFOREx; /* Prevent compiler warnings */
    ruleFOREx: ;

}
// $ANTLR end FOR

//   Comes from: 402:9: ( 'foreach' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOREACH
 *
 * Looks to match the characters the constitute the token FOREACH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFOREACH(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FOREACH;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:402:9: ( 'foreach' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:402:11: 'foreach'
    {
        MATCHS(lit_15); 
        if  (HASEXCEPTION())
        {
            goto ruleFOREACHEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFOREACHEx; /* Prevent compiler warnings */
    ruleFOREACHEx: ;

}
// $ANTLR end FOREACH

//   Comes from: 403:7: ( 'while' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHILE
 *
 * Looks to match the characters the constitute the token WHILE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHILE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHILE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:403:7: ( 'while' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:403:9: 'while'
    {
        MATCHS(lit_16); 
        if  (HASEXCEPTION())
        {
            goto ruleWHILEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHILEEx; /* Prevent compiler warnings */
    ruleWHILEEx: ;

}
// $ANTLR end WHILE

//   Comes from: 404:4: ( 'do' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DO
 *
 * Looks to match the characters the constitute the token DO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDO(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DO;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:404:4: ( 'do' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:404:6: 'do'
    {
        MATCHS(lit_17); 
        if  (HASEXCEPTION())
        {
            goto ruleDOEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDOEx; /* Prevent compiler warnings */
    ruleDOEx: ;

}
// $ANTLR end DO

//   Comes from: 405:8: ( 'switch' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SWITCH
 *
 * Looks to match the characters the constitute the token SWITCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSWITCH(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SWITCH;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:405:8: ( 'switch' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:405:10: 'switch'
    {
        MATCHS(lit_18); 
        if  (HASEXCEPTION())
        {
            goto ruleSWITCHEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSWITCHEx; /* Prevent compiler warnings */
    ruleSWITCHEx: ;

}
// $ANTLR end SWITCH

//   Comes from: 406:6: ( 'case' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CASE
 *
 * Looks to match the characters the constitute the token CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCASE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CASE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:406:6: ( 'case' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:406:8: 'case'
    {
        MATCHS(lit_19); 
        if  (HASEXCEPTION())
        {
            goto ruleCASEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCASEEx; /* Prevent compiler warnings */
    ruleCASEEx: ;

}
// $ANTLR end CASE

//   Comes from: 407:9: ( 'default' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DEFAULT
 *
 * Looks to match the characters the constitute the token DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDEFAULT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DEFAULT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:407:9: ( 'default' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:407:11: 'default'
    {
        MATCHS(lit_20); 
        if  (HASEXCEPTION())
        {
            goto ruleDEFAULTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDEFAULTEx; /* Prevent compiler warnings */
    ruleDEFAULTEx: ;

}
// $ANTLR end DEFAULT

//   Comes from: 408:7: ( 'break' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BREAK
 *
 * Looks to match the characters the constitute the token BREAK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBREAK(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BREAK;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:408:7: ( 'break' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:408:9: 'break'
    {
        MATCHS(lit_21); 
        if  (HASEXCEPTION())
        {
            goto ruleBREAKEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBREAKEx; /* Prevent compiler warnings */
    ruleBREAKEx: ;

}
// $ANTLR end BREAK

//   Comes from: 409:9: ( 'continue' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONTINUE
 *
 * Looks to match the characters the constitute the token CONTINUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONTINUE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONTINUE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:409:9: ( 'continue' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:409:11: 'continue'
    {
        MATCHS(lit_22); 
        if  (HASEXCEPTION())
        {
            goto ruleCONTINUEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCONTINUEEx; /* Prevent compiler warnings */
    ruleCONTINUEEx: ;

}
// $ANTLR end CONTINUE

//   Comes from: 410:8: ( 'return' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RETURN
 *
 * Looks to match the characters the constitute the token RETURN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRETURN(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RETURN;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:410:8: ( 'return' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:410:10: 'return'
    {
        MATCHS(lit_23); 
        if  (HASEXCEPTION())
        {
            goto ruleRETURNEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleRETURNEx; /* Prevent compiler warnings */
    ruleRETURNEx: ;

}
// $ANTLR end RETURN

//   Comes from: 411:4: ( 'if' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IF
 *
 * Looks to match the characters the constitute the token IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIF(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IF;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:411:4: ( 'if' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:411:6: 'if'
    {
        MATCHS(lit_24); 
        if  (HASEXCEPTION())
        {
            goto ruleIFEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIFEx; /* Prevent compiler warnings */
    ruleIFEx: ;

}
// $ANTLR end IF

//   Comes from: 412:6: ( 'else' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ELSE
 *
 * Looks to match the characters the constitute the token ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mELSE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ELSE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:412:6: ( 'else' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:412:8: 'else'
    {
        MATCHS(lit_25); 
        if  (HASEXCEPTION())
        {
            goto ruleELSEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleELSEEx; /* Prevent compiler warnings */
    ruleELSEEx: ;

}
// $ANTLR end ELSE

//   Comes from: 413:5: ( 'try' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRY
 *
 * Looks to match the characters the constitute the token TRY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTRY(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TRY;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:413:5: ( 'try' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:413:7: 'try'
    {
        MATCHS(lit_26); 
        if  (HASEXCEPTION())
        {
            goto ruleTRYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTRYEx; /* Prevent compiler warnings */
    ruleTRYEx: ;

}
// $ANTLR end TRY

//   Comes from: 414:7: ( 'catch' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CATCH
 *
 * Looks to match the characters the constitute the token CATCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCATCH(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CATCH;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:414:7: ( 'catch' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:414:9: 'catch'
    {
        MATCHS(lit_27); 
        if  (HASEXCEPTION())
        {
            goto ruleCATCHEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCATCHEx; /* Prevent compiler warnings */
    ruleCATCHEx: ;

}
// $ANTLR end CATCH

//   Comes from: 415:9: ( 'finally' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FINALLY
 *
 * Looks to match the characters the constitute the token FINALLY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFINALLY(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FINALLY;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:415:9: ( 'finally' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:415:11: 'finally'
    {
        MATCHS(lit_28); 
        if  (HASEXCEPTION())
        {
            goto ruleFINALLYEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFINALLYEx; /* Prevent compiler warnings */
    ruleFINALLYEx: ;

}
// $ANTLR end FINALLY

//   Comes from: 416:7: ( 'throw' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THROW
 *
 * Looks to match the characters the constitute the token THROW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHROW(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = THROW;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:416:7: ( 'throw' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:416:9: 'throw'
    {
        MATCHS(lit_29); 
        if  (HASEXCEPTION())
        {
            goto ruleTHROWEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleTHROWEx; /* Prevent compiler warnings */
    ruleTHROWEx: ;

}
// $ANTLR end THROW

//   Comes from: 418:9: ( 'null' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LITNULL
 *
 * Looks to match the characters the constitute the token LITNULL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLITNULL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LITNULL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:418:9: ( 'null' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:418:11: 'null'
    {
        MATCHS(lit_30); 
        if  (HASEXCEPTION())
        {
            goto ruleLITNULLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLITNULLEx; /* Prevent compiler warnings */
    ruleLITNULLEx: ;

}
// $ANTLR end LITNULL

//   Comes from: 419:9: ( 'true' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LITTRUE
 *
 * Looks to match the characters the constitute the token LITTRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLITTRUE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LITTRUE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:419:9: ( 'true' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:419:11: 'true'
    {
        MATCHS(lit_31); 
        if  (HASEXCEPTION())
        {
            goto ruleLITTRUEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLITTRUEEx; /* Prevent compiler warnings */
    ruleLITTRUEEx: ;

}
// $ANTLR end LITTRUE

//   Comes from: 420:9: ( 'false' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LITFALSE
 *
 * Looks to match the characters the constitute the token LITFALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLITFALSE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LITFALSE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:420:9: ( 'false' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:420:11: 'false'
    {
        MATCHS(lit_32); 
        if  (HASEXCEPTION())
        {
            goto ruleLITFALSEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLITFALSEEx; /* Prevent compiler warnings */
    ruleLITFALSEEx: ;

}
// $ANTLR end LITFALSE

//   Comes from: 422:5: ( '&&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND
 *
 * Looks to match the characters the constitute the token AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAND(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AND;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:422:5: ( '&&' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:422:7: '&&'
    {
        MATCHS(lit_33); 
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleANDEx; /* Prevent compiler warnings */
    ruleANDEx: ;

}
// $ANTLR end AND

//   Comes from: 423:4: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OR
 *
 * Looks to match the characters the constitute the token OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:423:4: ( '||' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:423:6: '||'
    {
        MATCHS(lit_34); 
        if  (HASEXCEPTION())
        {
            goto ruleOREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleOREx; /* Prevent compiler warnings */
    ruleOREx: ;

}
// $ANTLR end OR

//   Comes from: 424:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MUL
 *
 * Looks to match the characters the constitute the token MUL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMUL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MUL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:424:5: ( '*' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:424:7: '*'
    {
        MATCHC('*'); 
        if  (HASEXCEPTION())
        {
            goto ruleMULEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMULEx; /* Prevent compiler warnings */
    ruleMULEx: ;

}
// $ANTLR end MUL

//   Comes from: 425:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIV
 *
 * Looks to match the characters the constitute the token DIV
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIV(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DIV;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:425:5: ( '/' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:425:7: '/'
    {
        MATCHC('/'); 
        if  (HASEXCEPTION())
        {
            goto ruleDIVEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDIVEx; /* Prevent compiler warnings */
    ruleDIVEx: ;

}
// $ANTLR end DIV

//   Comes from: 426:5: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REM
 *
 * Looks to match the characters the constitute the token REM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREM(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REM;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:426:5: ( '%' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:426:7: '%'
    {
        MATCHC('%'); 
        if  (HASEXCEPTION())
        {
            goto ruleREMEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleREMEx; /* Prevent compiler warnings */
    ruleREMEx: ;

}
// $ANTLR end REM

//   Comes from: 427:6: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS
 *
 * Looks to match the characters the constitute the token PLUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPLUS(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PLUS;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:427:6: ( '+' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:427:8: '+'
    {
        MATCHC('+'); 
        if  (HASEXCEPTION())
        {
            goto rulePLUSEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePLUSEx; /* Prevent compiler warnings */
    rulePLUSEx: ;

}
// $ANTLR end PLUS

//   Comes from: 428:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS
 *
 * Looks to match the characters the constitute the token MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMINUS(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MINUS;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:428:7: ( '-' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:428:9: '-'
    {
        MATCHC('-'); 
        if  (HASEXCEPTION())
        {
            goto ruleMINUSEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleMINUSEx; /* Prevent compiler warnings */
    ruleMINUSEx: ;

}
// $ANTLR end MINUS

//   Comes from: 429:9: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITCOMPL
 *
 * Looks to match the characters the constitute the token BITCOMPL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITCOMPL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITCOMPL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:429:9: ( '~' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:429:11: '~'
    {
        MATCHC('~'); 
        if  (HASEXCEPTION())
        {
            goto ruleBITCOMPLEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBITCOMPLEx; /* Prevent compiler warnings */
    ruleBITCOMPLEx: ;

}
// $ANTLR end BITCOMPL

//   Comes from: 430:5: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT
 *
 * Looks to match the characters the constitute the token NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:430:5: ( '!' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:430:7: '!'
    {
        MATCHC('!'); 
        if  (HASEXCEPTION())
        {
            goto ruleNOTEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNOTEx; /* Prevent compiler warnings */
    ruleNOTEx: ;

}
// $ANTLR end NOT

//   Comes from: 431:8: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITAND
 *
 * Looks to match the characters the constitute the token BITAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITAND(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITAND;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:431:8: ( '&' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:431:10: '&'
    {
        MATCHC('&'); 
        if  (HASEXCEPTION())
        {
            goto ruleBITANDEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBITANDEx; /* Prevent compiler warnings */
    ruleBITANDEx: ;

}
// $ANTLR end BITAND

//   Comes from: 432:7: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITOR
 *
 * Looks to match the characters the constitute the token BITOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITOR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITOR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:432:7: ( '|' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:432:9: '|'
    {
        MATCHC('|'); 
        if  (HASEXCEPTION())
        {
            goto ruleBITOREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBITOREx; /* Prevent compiler warnings */
    ruleBITOREx: ;

}
// $ANTLR end BITOR

//   Comes from: 433:8: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITXOR
 *
 * Looks to match the characters the constitute the token BITXOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITXOR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITXOR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:433:8: ( '^' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:433:10: '^'
    {
        MATCHC('^'); 
        if  (HASEXCEPTION())
        {
            goto ruleBITXOREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleBITXOREx; /* Prevent compiler warnings */
    ruleBITXOREx: ;

}
// $ANTLR end BITXOR

//   Comes from: 434:6: ( '++' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INCR
 *
 * Looks to match the characters the constitute the token INCR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINCR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INCR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:434:6: ( '++' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:434:8: '++'
    {
        MATCHS(lit_35); 
        if  (HASEXCEPTION())
        {
            goto ruleINCREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINCREx; /* Prevent compiler warnings */
    ruleINCREx: ;

}
// $ANTLR end INCR

//   Comes from: 435:6: ( '--' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECR
 *
 * Looks to match the characters the constitute the token DECR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:435:6: ( '--' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:435:8: '--'
    {
        MATCHS(lit_36); 
        if  (HASEXCEPTION())
        {
            goto ruleDECREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleDECREx; /* Prevent compiler warnings */
    ruleDECREx: ;

}
// $ANTLR end DECR

//   Comes from: 436:7: ( '==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUAL
 *
 * Looks to match the characters the constitute the token EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUAL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EQUAL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:436:7: ( '==' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:436:9: '=='
    {
        MATCHS(lit_37); 
        if  (HASEXCEPTION())
        {
            goto ruleEQUALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleEQUALEx; /* Prevent compiler warnings */
    ruleEQUALEx: ;

}
// $ANTLR end EQUAL

//   Comes from: 437:9: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNEQUAL
 *
 * Looks to match the characters the constitute the token UNEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNEQUAL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UNEQUAL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:437:9: ( '!=' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:437:11: '!='
    {
        MATCHS(lit_38); 
        if  (HASEXCEPTION())
        {
            goto ruleUNEQUALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleUNEQUALEx; /* Prevent compiler warnings */
    ruleUNEQUALEx: ;

}
// $ANTLR end UNEQUAL

//   Comes from: 438:8: ( '<' '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEQUAL
 *
 * Looks to match the characters the constitute the token SEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEQUAL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SEQUAL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:438:8: ( '<' '=' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:438:10: '<' '='
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleSEQUALEx;
        }

        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleSEQUALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSEQUALEx; /* Prevent compiler warnings */
    ruleSEQUALEx: ;

}
// $ANTLR end SEQUAL

//   Comes from: 439:9: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SMALLER
 *
 * Looks to match the characters the constitute the token SMALLER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSMALLER(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SMALLER;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:439:9: ( '<' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:439:11: '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleSMALLEREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSMALLEREx; /* Prevent compiler warnings */
    ruleSMALLEREx: ;

}
// $ANTLR end SMALLER

//   Comes from: 440:9: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER
 *
 * Looks to match the characters the constitute the token GREATER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GREATER;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:440:9: ( '>' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:440:11: '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleGREATEREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGREATEREx; /* Prevent compiler warnings */
    ruleGREATEREx: ;

}
// $ANTLR end GREATER

//   Comes from: 441:8: ( '>' '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GEQUAL
 *
 * Looks to match the characters the constitute the token GEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGEQUAL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GEQUAL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:441:8: ( '>' '=' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:441:10: '>' '='
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleGEQUALEx;
        }

        MATCHC('='); 
        if  (HASEXCEPTION())
        {
            goto ruleGEQUALEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleGEQUALEx; /* Prevent compiler warnings */
    ruleGEQUALEx: ;

}
// $ANTLR end GEQUAL

//   Comes from: 442:8: ( '<' '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHIFTL
 *
 * Looks to match the characters the constitute the token SHIFTL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHIFTL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHIFTL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:442:8: ( '<' '<' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:442:10: '<' '<'
    {
        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTLEx;
        }

        MATCHC('<'); 
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTLEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSHIFTLEx; /* Prevent compiler warnings */
    ruleSHIFTLEx: ;

}
// $ANTLR end SHIFTL

//   Comes from: 443:8: ( '>' '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHIFTR
 *
 * Looks to match the characters the constitute the token SHIFTR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHIFTR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHIFTR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:443:8: ( '>' '>' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:443:10: '>' '>'
    {
        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTREx;
        }

        MATCHC('>'); 
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSHIFTREx; /* Prevent compiler warnings */
    ruleSHIFTREx: ;

}
// $ANTLR end SHIFTR

//   Comes from: 445:8: ( 'char' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_CHAR
 *
 * Looks to match the characters the constitute the token T_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_CHAR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_CHAR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:445:8: ( 'char' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:445:10: 'char'
    {
        MATCHS(lit_39); 
        if  (HASEXCEPTION())
        {
            goto ruleT_CHAREx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT_CHAREx; /* Prevent compiler warnings */
    ruleT_CHAREx: ;

}
// $ANTLR end T_CHAR

//   Comes from: 446:7: ( 'int' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_INT
 *
 * Looks to match the characters the constitute the token T_INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_INT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_INT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:446:7: ( 'int' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:446:9: 'int'
    {
        MATCHS(lit_40); 
        if  (HASEXCEPTION())
        {
            goto ruleT_INTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT_INTEx; /* Prevent compiler warnings */
    ruleT_INTEx: ;

}
// $ANTLR end T_INT

//   Comes from: 447:8: ( 'real' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_REAL
 *
 * Looks to match the characters the constitute the token T_REAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_REAL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_REAL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:447:8: ( 'real' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:447:10: 'real'
    {
        MATCHS(lit_41); 
        if  (HASEXCEPTION())
        {
            goto ruleT_REALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT_REALEx; /* Prevent compiler warnings */
    ruleT_REALEx: ;

}
// $ANTLR end T_REAL

//   Comes from: 448:9: ( 'string' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_STRING
 *
 * Looks to match the characters the constitute the token T_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_STRING(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_STRING;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:448:9: ( 'string' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:448:11: 'string'
    {
        MATCHS(lit_42); 
        if  (HASEXCEPTION())
        {
            goto ruleT_STRINGEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT_STRINGEx; /* Prevent compiler warnings */
    ruleT_STRINGEx: ;

}
// $ANTLR end T_STRING

//   Comes from: 449:8: ( 'boolean' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_BOOL
 *
 * Looks to match the characters the constitute the token T_BOOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_BOOL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_BOOL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:449:8: ( 'boolean' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:449:10: 'boolean'
    {
        MATCHS(lit_43); 
        if  (HASEXCEPTION())
        {
            goto ruleT_BOOLEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT_BOOLEx; /* Prevent compiler warnings */
    ruleT_BOOLEx: ;

}
// $ANTLR end T_BOOL

//   Comes from: 450:8: ( 'void' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_VOID
 *
 * Looks to match the characters the constitute the token T_VOID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_VOID(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_VOID;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:450:8: ( 'void' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:450:10: 'void'
    {
        MATCHS(lit_44); 
        if  (HASEXCEPTION())
        {
            goto ruleT_VOIDEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleT_VOIDEx; /* Prevent compiler warnings */
    ruleT_VOIDEx: ;

}
// $ANTLR end T_VOID

//   Comes from: 452:8: ( 'static' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STATIC
 *
 * Looks to match the characters the constitute the token STATIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTATIC(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STATIC;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:452:8: ( 'static' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:452:10: 'static'
    {
        MATCHS(lit_45); 
        if  (HASEXCEPTION())
        {
            goto ruleSTATICEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTATICEx; /* Prevent compiler warnings */
    ruleSTATICEx: ;

}
// $ANTLR end STATIC

//   Comes from: 453:7: ( 'final' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FINAL
 *
 * Looks to match the characters the constitute the token FINAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFINAL(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FINAL;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:453:7: ( 'final' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:453:9: 'final'
    {
        MATCHS(lit_46); 
        if  (HASEXCEPTION())
        {
            goto ruleFINALEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFINALEx; /* Prevent compiler warnings */
    ruleFINALEx: ;

}
// $ANTLR end FINAL

//   Comes from: 454:9: ( 'abstract' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ABSTRACT
 *
 * Looks to match the characters the constitute the token ABSTRACT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mABSTRACT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ABSTRACT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:454:9: ( 'abstract' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:454:11: 'abstract'
    {
        MATCHS(lit_47); 
        if  (HASEXCEPTION())
        {
            goto ruleABSTRACTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleABSTRACTEx; /* Prevent compiler warnings */
    ruleABSTRACTEx: ;

}
// $ANTLR end ABSTRACT

//   Comes from: 455:8: ( 'native' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NATIVE
 *
 * Looks to match the characters the constitute the token NATIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNATIVE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NATIVE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:455:8: ( 'native' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:455:10: 'native'
    {
        MATCHS(lit_48); 
        if  (HASEXCEPTION())
        {
            goto ruleNATIVEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleNATIVEEx; /* Prevent compiler warnings */
    ruleNATIVEEx: ;

}
// $ANTLR end NATIVE

//   Comes from: 456:6: ( 'synchronized' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SYNC
 *
 * Looks to match the characters the constitute the token SYNC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSYNC(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SYNC;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:456:6: ( 'synchronized' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:456:8: 'synchronized'
    {
        MATCHS(lit_49); 
        if  (HASEXCEPTION())
        {
            goto ruleSYNCEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSYNCEx; /* Prevent compiler warnings */
    ruleSYNCEx: ;

}
// $ANTLR end SYNC

//   Comes from: 457:8: ( 'public' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PUBLIC
 *
 * Looks to match the characters the constitute the token PUBLIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPUBLIC(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PUBLIC;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:457:8: ( 'public' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:457:10: 'public'
    {
        MATCHS(lit_50); 
        if  (HASEXCEPTION())
        {
            goto rulePUBLICEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePUBLICEx; /* Prevent compiler warnings */
    rulePUBLICEx: ;

}
// $ANTLR end PUBLIC

//   Comes from: 458:6: ( 'protected' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROT
 *
 * Looks to match the characters the constitute the token PROT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPROT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PROT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:458:6: ( 'protected' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:458:8: 'protected'
    {
        MATCHS(lit_51); 
        if  (HASEXCEPTION())
        {
            goto rulePROTEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePROTEx; /* Prevent compiler warnings */
    rulePROTEx: ;

}
// $ANTLR end PROT

//   Comes from: 459:9: ( 'private' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRIVATE
 *
 * Looks to match the characters the constitute the token PRIVATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRIVATE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PRIVATE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:459:9: ( 'private' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:459:11: 'private'
    {
        MATCHS(lit_52); 
        if  (HASEXCEPTION())
        {
            goto rulePRIVATEEx;
        }



    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto rulePRIVATEEx; /* Prevent compiler warnings */
    rulePRIVATEEx: ;

}
// $ANTLR end PRIVATE

//   Comes from: 461:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEP
 *
 * Looks to match the characters the constitute the token SEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEP(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SEP;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:461:5: ( ';' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:461:7: ';'
    {
        MATCHC(';'); 
        if  (HASEXCEPTION())
        {
            goto ruleSEPEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSEPEx; /* Prevent compiler warnings */
    ruleSEPEx: ;

}
// $ANTLR end SEP

//   Comes from: 463:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ID;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:463:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:463:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleIDEx;
        }


        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:463:31: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*

        for (;;)
        {
            int alt1=2;
            switch ( LA(1) ) 
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt1=1;
            	}
                break;

            }

            switch (alt1) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleIDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
    ruleIDEx: ;

}
// $ANTLR end ID

//   Comes from: 466:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT
 *
 * Looks to match the characters the constitute the token INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:466:5: ( ( '0' .. '9' )+ )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:466:7: ( '0' .. '9' )+
    {
        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:466:7: ( '0' .. '9' )+
        {
            int cnt2=0;

            for (;;)
            {
                int alt2=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt2=1;
        		}
        	    break;

        	}

        	switch (alt2) 
        	{
        	    case 1:
        	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:466:7: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleINTEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt2 >= 1 )
        		{
        		    goto loop2;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleINTEx;
        	}
        	cnt2++;
            }
            loop2: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleINTEx; /* Prevent compiler warnings */
    ruleINTEx: ;

}
// $ANTLR end INT

//   Comes from: 470:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOAT;
       
    
    {
        //  D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )
        
        ANTLR3_UINT32 alt9;

        alt9=3;

        alt9 = cdfa9.predict(ctx, RECOGNIZER, ISTREAM, &cdfa9);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATEx;
        }

        switch (alt9) 
        {
    	case 1:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
    	    {
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:9: ( '0' .. '9' )+
    	        {
    	            int cnt3=0;

    	            for (;;)
    	            {
    	                int alt3=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt3=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt3) 
    	        	{
    	        	    case 1:
    	        	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt3 >= 1 )
    	        		{
    	        		    goto loop3;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATEx;
    	        	}
    	        	cnt3++;
    	            }
    	            loop3: ;	/* Jump to here if this rule does not match */
    	        }
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATEx;
    	        }


    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt4=2;
    	            switch ( LA(1) ) 
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt4=1;
    	            	}
    	                break;

    	            }

    	            switch (alt4) 
    	            {
    	        	case 1:
    	        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:26: '0' .. '9'
    	        	    {
    	        	        MATCHRANGE('0', '9'); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop4;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop4: ; /* Jump out to here if this rule does not match */


    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:37: ( EXPONENT )?
    	        {
    	            int alt5=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'E':
    	                case 'e':
    	                	{
    	                		alt5=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt5) 
    	            {
    	        	case 1:
    	        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:470:37: EXPONENT
    	        	    {
    	        	        /* 470:37: EXPONENT */
    	        	        mEXPONENT(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:471:9: '.' ( '0' .. '9' )+ ( EXPONENT )?
    	    {
    	        MATCHC('.'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATEx;
    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:471:13: ( '0' .. '9' )+
    	        {
    	            int cnt6=0;

    	            for (;;)
    	            {
    	                int alt6=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt6=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt6) 
    	        	{
    	        	    case 1:
    	        	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:471:14: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt6 >= 1 )
    	        		{
    	        		    goto loop6;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATEx;
    	        	}
    	        	cnt6++;
    	            }
    	            loop6: ;	/* Jump to here if this rule does not match */
    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:471:25: ( EXPONENT )?
    	        {
    	            int alt7=2;
    	            switch ( LA(1) ) 
    	            {
    	                case 'E':
    	                case 'e':
    	                	{
    	                		alt7=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt7) 
    	            {
    	        	case 1:
    	        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:471:25: EXPONENT
    	        	    {
    	        	        /* 471:25: EXPONENT */
    	        	        mEXPONENT(ctx ); 
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATEx;
    	        	        }


    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:472:9: ( '0' .. '9' )+ EXPONENT
    	    {
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:472:9: ( '0' .. '9' )+
    	        {
    	            int cnt8=0;

    	            for (;;)
    	            {
    	                int alt8=2;
    	        	switch ( LA(1) ) 
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt8=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt8) 
    	        	{
    	        	    case 1:
    	        	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:472:10: '0' .. '9'
    	        	        {
    	        	            MATCHRANGE('0', '9'); 
    	        	            if  (HASEXCEPTION())
    	        	            {
    	        	                goto ruleFLOATEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:
    	        	    
    	        		if ( cnt8 >= 1 )
    	        		{
    	        		    goto loop8;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATEx;
    	        	}
    	        	cnt8++;
    	            }
    	            loop8: ;	/* Jump to here if this rule does not match */
    	        }
    	        /* 472:9: ( '0' .. '9' )+ EXPONENT */
    	        mEXPONENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATEx;
    	        }


    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
    ruleFLOATEx: ;

}
// $ANTLR end FLOAT

//   Comes from: 476:5: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHITESPACE;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:476:5: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:476:7: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
    {
        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:476:7: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
        {
            int cnt10=0;

            for (;;)
            {
                int alt10=2;
        	switch ( LA(1) ) 
        	{
        	case '\t':
        	case '\n':
        	case '\f':
        	case '\r':
        	case ' ':
        		{
        			alt10=1;
        		}
        	    break;

        	}

        	switch (alt10) 
        	{
        	    case 1:
        	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:
        	        {
        	            if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        	            {
        	                CONSUME();

        	            }
        	            else 
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();    goto ruleWHITESPACEEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt10 >= 1 )
        		{
        		    goto loop10;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWHITESPACEEx;
        	}
        	cnt10++;
            }
            loop10: ;	/* Jump to here if this rule does not match */
        }
        {
             LEXSTATE->channel = HIDDEN; 
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

//   Comes from: 480:5: ( '\"' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:480:5: ( '\"' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )* '\"' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:480:8: '\"' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )* '\"'
    {
        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }


        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:480:12: ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt11=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA11_0 = LA(1);
                if ( (LA11_0 == '\\')) 
                {
                    alt11=1;
                }
                else if ( (((LA11_0 >= 0x0000) && (LA11_0 <= '!')) || ((LA11_0 >= '#') && (LA11_0 <= '[')) || ((LA11_0 >= ']') && (LA11_0 <= 0xFFFF)))) 
                {
                    alt11=2;
                }

            }
            switch (alt11) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:480:14: ESC_SEQ
        	    {
        	        /* 480:14: ESC_SEQ */
        	        mESC_SEQ(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRINGEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:480:24: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleSTRINGEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop11;	/* break out of the loop */
        	    break;
            }
        }
        loop11: ; /* Jump out to here if this rule does not match */

        MATCHC('"'); 
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
    ruleSTRINGEx: ;

}
// $ANTLR end STRING

//   Comes from: 483:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) ) '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR
 *
 * Looks to match the characters the constitute the token CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHAR(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CHAR;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:483:5: ( '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) ) '\\'' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:483:8: '\\'' ( ESC_SEQ | ~ ( '\\\\' | '\"' ) ) '\\''
    {
        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleCHAREx;
        }


        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:483:13: ( ESC_SEQ | ~ ( '\\\\' | '\"' ) )
        {
            int alt12=2;

            {
                int LA12_0 = LA(1);
                if ( (LA12_0 == '\\')) 
                {
                    alt12=1;
                }
                else if ( (((LA12_0 >= 0x0000) && (LA12_0 <= '!')) || ((LA12_0 >= '#') && (LA12_0 <= '[')) || ((LA12_0 >= ']') && (LA12_0 <= 0xFFFF)))) 
                {
                    alt12=2;
                }
                else 
                {
                
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleCHAREx;
                }
            }
            switch (alt12) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:483:14: ESC_SEQ
        	    {
        	        /* 483:14: ESC_SEQ */
        	        mESC_SEQ(ctx ); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHAREx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:483:24: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleCHAREx;
        	        }


        	    }
        	    break;

            }
        }
        MATCHC('\''); 
        if  (HASEXCEPTION())
        {
            goto ruleCHAREx;
        }


    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCHAREx; /* Prevent compiler warnings */
    ruleCHAREx: ;

}
// $ANTLR end CHAR

//   Comes from: 487:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:487:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:487:9: '/*' ( options {greedy=false; } : . )* '*/'
    {
        MATCHS(lit_53); 
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }



        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:487:14: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt13=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA13_0 = LA(1);
                if ( (LA13_0 == '*')) 
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA13_1 = LA(2);
                        if ( (LA13_1 == '/')) 
                        {
                            alt13=2;
                        }
                        else if ( (((LA13_1 >= 0x0000) && (LA13_1 <= '.')) || ((LA13_1 >= '0') && (LA13_1 <= 0xFFFF)))) 
                        {
                            alt13=1;
                        }

                    }
                }
                else if ( (((LA13_0 >= 0x0000) && (LA13_0 <= ')')) || ((LA13_0 >= '+') && (LA13_0 <= 0xFFFF)))) 
                {
                    alt13=1;
                }

            }
            switch (alt13) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:487:42: .
        	    {
        	        MATCHANY(); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop13;	/* break out of the loop */
        	    break;
            }
        }
        loop13: ; /* Jump out to here if this rule does not match */

        MATCHS(lit_54); 
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }


        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 491:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINE_COMMENT
 *
 * Looks to match the characters the constitute the token LINE_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINE_COMMENT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LINE_COMMENT;
       
    
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:491:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:491:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHS(lit_55); 
        if  (HASEXCEPTION())
        {
            goto ruleLINE_COMMENTEx;
        }



        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:491:12: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt14=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA14_0 = LA(1);
                if ( (((LA14_0 >= 0x0000) && (LA14_0 <= '\t')) || ((LA14_0 >= 0x000B) && (LA14_0 <= '\f')) || ((LA14_0 >= 0x000E) && (LA14_0 <= 0xFFFF)))) 
                {
                    alt14=1;
                }

            }
            switch (alt14) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:491:12: ~ ( '\\n' | '\\r' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop14;	/* break out of the loop */
        	    break;
            }
        }
        loop14: ; /* Jump out to here if this rule does not match */


        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:491:26: ( '\\r' )?
        {
            int alt15=2;
            switch ( LA(1) ) 
            {
                case '\r':
                	{
                		alt15=1;
                	}
                    break;
            }

            switch (alt15) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:491:26: '\\r'
        	    {
        	        MATCHC('\r'); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

            }
        }
        MATCHC('\n'); 
        if  (HASEXCEPTION())
        {
            goto ruleLINE_COMMENTEx;
        }

        {
            LEXSTATE->channel=HIDDEN;
        }

    }

	LEXSTATE->type = _type;

    // This is where rules clean up and exit
    //
    goto ruleLINE_COMMENTEx; /* Prevent compiler warnings */
    ruleLINE_COMMENTEx: ;

}
// $ANTLR end LINE_COMMENT

//   Comes from: 495:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:495:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:495:12: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleEXPONENTEx;
        }


        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:495:22: ( '+' | '-' )?
        {
            int alt16=2;
            switch ( LA(1) ) 
            {
                case '+':
                case '-':
                	{
                		alt16=1;
                	}
                    break;
            }

            switch (alt16) 
            {
        	case 1:
        	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();

        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();    goto ruleEXPONENTEx;
        	        }


        	    }
        	    break;

            }
        }
        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:495:33: ( '0' .. '9' )+
        {
            int cnt17=0;

            for (;;)
            {
                int alt17=2;
        	switch ( LA(1) ) 
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt17=1;
        		}
        	    break;

        	}

        	switch (alt17) 
        	{
        	    case 1:
        	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:495:34: '0' .. '9'
        	        {
        	            MATCHRANGE('0', '9'); 
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruleEXPONENTEx;
        	            }


        	        }
        	        break;

        	    default:
        	    
        		if ( cnt17 >= 1 )
        		{
        		    goto loop17;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleEXPONENTEx;
        	}
        	cnt17++;
            }
            loop17: ;	/* Jump to here if this rule does not match */
        }

    }



    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 498:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:498:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:498:13: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();

        }
        else 
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();    goto ruleHEX_DIGITEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
    ruleHEX_DIGITEx: ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 502:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESC_SEQ
 *
 * Looks to match the characters the constitute the token ESC_SEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESC_SEQ(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  D:\\Development\\armybuilder\\src\\armyscript\\as.g:502:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )
        
        ANTLR3_UINT32 alt18;

        alt18=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '"':
        		case '\'':
        		case '\\':
        		case 'b':
        		case 'f':
        		case 'n':
        		case 'r':
        		case 't':
        			{
        				alt18=1;
        			}
        		    break;
        		case 'u':
        			{
        				alt18=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				alt18=3;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 18;
        		    EXCEPTION->state        = 1;


        		    goto ruleESC_SEQEx;
        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 18;
            EXCEPTION->state        = 0;


            goto ruleESC_SEQEx;
        }

        switch (alt18) 
        {
    	case 1:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:502:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESC_SEQEx;
    	        }

    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
    	        {
    	            CONSUME();

    	        }
    	        else 
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();    goto ruleESC_SEQEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:503:9: UNICODE_ESC
    	    {
    	        /* 503:9: UNICODE_ESC */
    	        mUNICODE_ESC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESC_SEQEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:504:9: OCTAL_ESC
    	    {
    	        /* 504:9: OCTAL_ESC */
    	        mOCTAL_ESC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESC_SEQEx;
    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleESC_SEQEx; /* Prevent compiler warnings */
    ruleESC_SEQEx: ;

}
// $ANTLR end ESC_SEQ

//   Comes from: 509:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESC
 *
 * Looks to match the characters the constitute the token OCTAL_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESC(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    {
        //  D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
        
        ANTLR3_UINT32 alt19;

        alt19=3;

        switch ( LA(1) ) 
        {
        case '\\':
        	{
        		switch ( LA(2) ) 
        		{
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						switch ( LA(4) ) 
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        							{
        								alt19=1;
        							}
        						    break;

        						default:
        						    alt19=2;}

        					}
        				    break;

        				default:
        				    alt19=3;}

        			}
        		    break;
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				switch ( LA(3) ) 
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						alt19=2;
        					}
        				    break;

        				default:
        				    alt19=3;}

        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 19;
        		    EXCEPTION->state        = 1;


        		    goto ruleOCTAL_ESCEx;
        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 19;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCEx;
        }

        switch (alt19) 
        {
    	case 1:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCEx;
    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:14: ( '0' .. '3' )
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:15: '0' .. '3'
    	        {
    	            MATCHRANGE('0', '3'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCEx;
    	            }


    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:25: ( '0' .. '7' )
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCEx;
    	            }


    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:36: ( '0' .. '7' )
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:509:37: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCEx;
    	            }


    	        }


    	    }
    	    break;
    	case 2:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:510:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCEx;
    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:510:14: ( '0' .. '7' )
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:510:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCEx;
    	            }


    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:510:25: ( '0' .. '7' )
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:510:26: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCEx;
    	            }


    	        }


    	    }
    	    break;
    	case 3:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:511:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\'); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCEx;
    	        }

    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:511:14: ( '0' .. '7' )
    	        // D:\\Development\\armybuilder\\src\\armyscript\\as.g:511:15: '0' .. '7'
    	        {
    	            MATCHRANGE('0', '7'); 
    	            if  (HASEXCEPTION())
    	            {
    	                goto ruleOCTAL_ESCEx;
    	            }


    	        }


    	    }
    	    break;

        }
    }


    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCEx; /* Prevent compiler warnings */
    ruleOCTAL_ESCEx: ;

}
// $ANTLR end OCTAL_ESC

//   Comes from: 516:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESC
 *
 * Looks to match the characters the constitute the token UNICODE_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESC(pasLexer ctx)
{
	ANTLR3_UINT32	_type;

        
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:516:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:516:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }

        MATCHC('u'); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }

        /* 516:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }

        /* 516:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }

        /* 516:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }

        /* 516:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx ); 
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }


    }



    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCEx; /* Prevent compiler warnings */
    ruleUNICODE_ESCEx: ;

}
// $ANTLR end UNICODE_ESC

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(pasLexer ctx)
{
    {
        //  D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:8: ( T__113 | T__114 | T__115 | T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | PACKAGE | USE | CLASS | INTRFACE | SUPER | THIS | EXTENDS | IMPL | NEW | INST_OF | ASSERT | FOR | FOREACH | WHILE | DO | SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN | IF | ELSE | TRY | CATCH | FINALLY | THROW | LITNULL | LITTRUE | LITFALSE | AND | OR | MUL | DIV | REM | PLUS | MINUS | BITCOMPL | NOT | BITAND | BITOR | BITXOR | INCR | DECR | EQUAL | UNEQUAL | SEQUAL | SMALLER | GREATER | GEQUAL | SHIFTL | SHIFTR | T_CHAR | T_INT | T_REAL | T_STRING | T_BOOL | T_VOID | STATIC | FINAL | ABSTRACT | NATIVE | SYNC | PUBLIC | PROT | PRIVATE | SEP | ID | INT | FLOAT | WHITESPACE | STRING | CHAR | COMMENT | LINE_COMMENT )
        
        ANTLR3_UINT32 alt20;

        alt20=88;

        alt20 = cdfa20.predict(ctx, RECOGNIZER, ISTREAM, &cdfa20);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt20) 
        {
    	case 1:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:10: T__113
    	    {
    	        /* 1:10: T__113 */
    	        mT__113(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:17: T__114
    	    {
    	        /* 1:17: T__114 */
    	        mT__114(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:24: T__115
    	    {
    	        /* 1:24: T__115 */
    	        mT__115(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 4:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:31: T__116
    	    {
    	        /* 1:31: T__116 */
    	        mT__116(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 5:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:38: T__117
    	    {
    	        /* 1:38: T__117 */
    	        mT__117(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 6:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:45: T__118
    	    {
    	        /* 1:45: T__118 */
    	        mT__118(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 7:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:52: T__119
    	    {
    	        /* 1:52: T__119 */
    	        mT__119(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 8:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:59: T__120
    	    {
    	        /* 1:59: T__120 */
    	        mT__120(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 9:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:66: T__121
    	    {
    	        /* 1:66: T__121 */
    	        mT__121(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 10:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:73: T__122
    	    {
    	        /* 1:73: T__122 */
    	        mT__122(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 11:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:80: T__123
    	    {
    	        /* 1:80: T__123 */
    	        mT__123(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 12:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:87: T__124
    	    {
    	        /* 1:87: T__124 */
    	        mT__124(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 13:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:94: T__125
    	    {
    	        /* 1:94: T__125 */
    	        mT__125(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 14:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:101: PACKAGE
    	    {
    	        /* 1:101: PACKAGE */
    	        mPACKAGE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 15:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:109: USE
    	    {
    	        /* 1:109: USE */
    	        mUSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 16:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:113: CLASS
    	    {
    	        /* 1:113: CLASS */
    	        mCLASS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 17:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:119: INTRFACE
    	    {
    	        /* 1:119: INTRFACE */
    	        mINTRFACE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 18:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:128: SUPER
    	    {
    	        /* 1:128: SUPER */
    	        mSUPER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 19:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:134: THIS
    	    {
    	        /* 1:134: THIS */
    	        mTHIS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 20:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:139: EXTENDS
    	    {
    	        /* 1:139: EXTENDS */
    	        mEXTENDS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 21:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:147: IMPL
    	    {
    	        /* 1:147: IMPL */
    	        mIMPL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 22:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:152: NEW
    	    {
    	        /* 1:152: NEW */
    	        mNEW(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 23:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:156: INST_OF
    	    {
    	        /* 1:156: INST_OF */
    	        mINST_OF(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 24:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:164: ASSERT
    	    {
    	        /* 1:164: ASSERT */
    	        mASSERT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 25:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:171: FOR
    	    {
    	        /* 1:171: FOR */
    	        mFOR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 26:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:175: FOREACH
    	    {
    	        /* 1:175: FOREACH */
    	        mFOREACH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 27:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:183: WHILE
    	    {
    	        /* 1:183: WHILE */
    	        mWHILE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 28:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:189: DO
    	    {
    	        /* 1:189: DO */
    	        mDO(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 29:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:192: SWITCH
    	    {
    	        /* 1:192: SWITCH */
    	        mSWITCH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 30:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:199: CASE
    	    {
    	        /* 1:199: CASE */
    	        mCASE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 31:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:204: DEFAULT
    	    {
    	        /* 1:204: DEFAULT */
    	        mDEFAULT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 32:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:212: BREAK
    	    {
    	        /* 1:212: BREAK */
    	        mBREAK(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 33:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:218: CONTINUE
    	    {
    	        /* 1:218: CONTINUE */
    	        mCONTINUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 34:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:227: RETURN
    	    {
    	        /* 1:227: RETURN */
    	        mRETURN(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 35:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:234: IF
    	    {
    	        /* 1:234: IF */
    	        mIF(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 36:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:237: ELSE
    	    {
    	        /* 1:237: ELSE */
    	        mELSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 37:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:242: TRY
    	    {
    	        /* 1:242: TRY */
    	        mTRY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 38:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:246: CATCH
    	    {
    	        /* 1:246: CATCH */
    	        mCATCH(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 39:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:252: FINALLY
    	    {
    	        /* 1:252: FINALLY */
    	        mFINALLY(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 40:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:260: THROW
    	    {
    	        /* 1:260: THROW */
    	        mTHROW(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 41:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:266: LITNULL
    	    {
    	        /* 1:266: LITNULL */
    	        mLITNULL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 42:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:274: LITTRUE
    	    {
    	        /* 1:274: LITTRUE */
    	        mLITTRUE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 43:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:282: LITFALSE
    	    {
    	        /* 1:282: LITFALSE */
    	        mLITFALSE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 44:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:291: AND
    	    {
    	        /* 1:291: AND */
    	        mAND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 45:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:295: OR
    	    {
    	        /* 1:295: OR */
    	        mOR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 46:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:298: MUL
    	    {
    	        /* 1:298: MUL */
    	        mMUL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 47:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:302: DIV
    	    {
    	        /* 1:302: DIV */
    	        mDIV(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 48:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:306: REM
    	    {
    	        /* 1:306: REM */
    	        mREM(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 49:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:310: PLUS
    	    {
    	        /* 1:310: PLUS */
    	        mPLUS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 50:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:315: MINUS
    	    {
    	        /* 1:315: MINUS */
    	        mMINUS(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 51:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:321: BITCOMPL
    	    {
    	        /* 1:321: BITCOMPL */
    	        mBITCOMPL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 52:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:330: NOT
    	    {
    	        /* 1:330: NOT */
    	        mNOT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 53:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:334: BITAND
    	    {
    	        /* 1:334: BITAND */
    	        mBITAND(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 54:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:341: BITOR
    	    {
    	        /* 1:341: BITOR */
    	        mBITOR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 55:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:347: BITXOR
    	    {
    	        /* 1:347: BITXOR */
    	        mBITXOR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 56:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:354: INCR
    	    {
    	        /* 1:354: INCR */
    	        mINCR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 57:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:359: DECR
    	    {
    	        /* 1:359: DECR */
    	        mDECR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 58:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:364: EQUAL
    	    {
    	        /* 1:364: EQUAL */
    	        mEQUAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 59:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:370: UNEQUAL
    	    {
    	        /* 1:370: UNEQUAL */
    	        mUNEQUAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 60:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:378: SEQUAL
    	    {
    	        /* 1:378: SEQUAL */
    	        mSEQUAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 61:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:385: SMALLER
    	    {
    	        /* 1:385: SMALLER */
    	        mSMALLER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 62:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:393: GREATER
    	    {
    	        /* 1:393: GREATER */
    	        mGREATER(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 63:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:401: GEQUAL
    	    {
    	        /* 1:401: GEQUAL */
    	        mGEQUAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 64:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:408: SHIFTL
    	    {
    	        /* 1:408: SHIFTL */
    	        mSHIFTL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 65:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:415: SHIFTR
    	    {
    	        /* 1:415: SHIFTR */
    	        mSHIFTR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 66:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:422: T_CHAR
    	    {
    	        /* 1:422: T_CHAR */
    	        mT_CHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 67:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:429: T_INT
    	    {
    	        /* 1:429: T_INT */
    	        mT_INT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 68:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:435: T_REAL
    	    {
    	        /* 1:435: T_REAL */
    	        mT_REAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 69:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:442: T_STRING
    	    {
    	        /* 1:442: T_STRING */
    	        mT_STRING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 70:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:451: T_BOOL
    	    {
    	        /* 1:451: T_BOOL */
    	        mT_BOOL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 71:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:458: T_VOID
    	    {
    	        /* 1:458: T_VOID */
    	        mT_VOID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 72:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:465: STATIC
    	    {
    	        /* 1:465: STATIC */
    	        mSTATIC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 73:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:472: FINAL
    	    {
    	        /* 1:472: FINAL */
    	        mFINAL(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 74:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:478: ABSTRACT
    	    {
    	        /* 1:478: ABSTRACT */
    	        mABSTRACT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 75:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:487: NATIVE
    	    {
    	        /* 1:487: NATIVE */
    	        mNATIVE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 76:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:494: SYNC
    	    {
    	        /* 1:494: SYNC */
    	        mSYNC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 77:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:499: PUBLIC
    	    {
    	        /* 1:499: PUBLIC */
    	        mPUBLIC(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 78:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:506: PROT
    	    {
    	        /* 1:506: PROT */
    	        mPROT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 79:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:511: PRIVATE
    	    {
    	        /* 1:511: PRIVATE */
    	        mPRIVATE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 80:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:519: SEP
    	    {
    	        /* 1:519: SEP */
    	        mSEP(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 81:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:523: ID
    	    {
    	        /* 1:523: ID */
    	        mID(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 82:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:526: INT
    	    {
    	        /* 1:526: INT */
    	        mINT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 83:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:530: FLOAT
    	    {
    	        /* 1:530: FLOAT */
    	        mFLOAT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 84:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:536: WHITESPACE
    	    {
    	        /* 1:536: WHITESPACE */
    	        mWHITESPACE(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 85:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:547: STRING
    	    {
    	        /* 1:547: STRING */
    	        mSTRING(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 86:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:554: CHAR
    	    {
    	        /* 1:554: CHAR */
    	        mCHAR(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 87:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:559: COMMENT
    	    {
    	        /* 1:559: COMMENT */
    	        mCOMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;
    	case 88:
    	    // D:\\Development\\armybuilder\\src\\armyscript\\as.g:1:567: LINE_COMMENT
    	    {
    	        /* 1:567: LINE_COMMENT */
    	        mLINE_COMMENT(ctx ); 
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }


    	    }
    	    break;

        }
    }

    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */ 


/* End of code
 * =============================================================================
 */
