/***************************************************************************
 *   Copyright (C) 2006 by Jeroen Broekhuizen                              *
 *   jengine.sse@live.nl                                                   *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Library General Public License as       *
 *   published by the Free Software Foundation; either version 2 of the    *
 *   License, or (at your option) any later version.                       *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU Library General Public     *
 *   License along with this program; if not, write to the                 *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 ***************************************************************************/
#include "scriptmanager.h"
#ifndef JENGINE_INLINE
#  include "scriptmanager.inl"
#endif

#include <iostream>
#include <sstream>
#include <tolua++.h>

#include "core/log/log.h"

#include "tolua_core.h"
#include "scriptcontext.h"

#define LUA_SCRIPTLIBNAME "script"

ScriptManager::ScriptManager():
   luaState(NULL),
   tempScript(),
   requests(),
   job(0)
{
}

/// \fn ScriptManager::initialize()
/// \brief Initializes the Lua scripting environment with the default modules and the
/// engines exported classes. Call this function before any of the other functions.
/// \returns false if the Lua state could not be created, true otherwise
bool ScriptManager::initialize()
{
	// see if we can link lua
	luaState = lua_open();
	if (luaState == NULL)
		return false;

	luaL_openlibs(luaState);

   tolua_open(luaState);
   
   registerGlobals();

   tempScript.setState(luaState);
	return true;
}

/// \fn ScriptManager::destroy()
/// \brief Releases the Lua scripting environment. After calling this function you must
/// first call initialize() before calling any other functions
/// \returns false if the Lua state could not be created, true otherwise
void ScriptManager::destroy()
{
	if (luaState)
   {
		// release lua
		lua_close (luaState);
		luaState = NULL;
	}
}

/// \fn ScriptManager::loadModule(int (*tolua_Module)(lua_State* tolua_S))
/// \brief Calls the function tolua_Module to load it in the global Lua state. These tolua_Module
/// functions are generated automatically by tolua.
/// \param *tolua_Module pointer to the module function generated by tolua
void ScriptManager::loadModule(initializer module)
{
	// load the module in this state
	(*module)(luaState);
}

/// \fn ScriptManager::executeScript(const std::string& script)
/// \brief Runs a script once in either the main lua state, or a child state.
/// \param script Name of the script file
/// \param child Flag which should be set if the script should be run in a child state (default is false)
bool ScriptManager::executeScript(ScriptContext& context, const std::string& script, bool child)
{
   Script luaScript(luaState, child);
   return luaScript.load(context, script);
}

/// \fn ScriptManager::executeLine(const char* line, bool child)
/// \brief Executes a line of Lua code.
bool ScriptManager::executeLine(ScriptContext& context, const char* line)
{
   if ( luaL_dostring(luaState, line) != 0 )
   {
      context.info(Log::eError, lua_tostring(luaState, -1));
      return false;
   }
   return true;
}

/// \fn ScriptManager::setObject(void* obj, const char* type, const char* var)
/// \brief Sets a global variable in the Lua scripting environment with name 'var'.
/// \param obj pointer to a valid object
/// \param type type of the object (must be a valid type specifier)
/// \param var name of the variable as known within Lua
void ScriptManager::setObject(void* obj, const char* type, const char* var)
{
   tolua_pushusertype (luaState, obj, type);
	lua_setglobal (luaState, var);
}

//-----------------------------------------
// - Registered functions
//-----------------------------------------

static int include(lua_State* L)
{
   ASSERT(lua_gettop(L) == 1);

   const std::string file = luaL_checkstring(L, 1);

   ScriptContext context;

   lua_getglobal(L, LUA_SCRIPTLIBNAME);
   ScriptManager* pmanager = static_cast<ScriptManager*>(lua_touserdata(L,-1));
   pmanager->executeScript(context, file, false);

   return 0;
}

void ScriptManager::registerGlobals()
{
   tolua_core_open(luaState);

   setObject(this, "ScriptManager", "script");

   lua_register(luaState, "include", include);
}

//-----------------------------------------
// - Scheduling interface
//-----------------------------------------

/// \fn ScriptManager::update(Uint32 tick)
/// \brief Checks the request list and executes scripts when necessary.
void ScriptManager::update(ScriptContext& context, float delta)
{
   Requests::iterator it = requests.begin();
   while ( it != requests.end() )
   {
      Requests::iterator next = it;
      Request& request = *it;
      ++next;

      request.mCurrentTime += delta;

      if ( request.mCurrentTime >= request.mStartTime )
      {
         // execute the function
         Script& script = getTemporaryScript();
         script.prepareCall(request.mFunction.c_str());
         script.run(context);

         // remove request from the list
         requests.erase(it);
      }

      it = next;
   }
}

/// \fn ScriptManager::schedule(const std::string& fnc, float time)
/// \brief Schedules a script for running after time milli seconds passed.
uint ScriptManager::schedule(const std::string& fnc, float time)
{
   Request req;
   req.mJobId       = job++;
   req.mFunction    = fnc;
   req.mStartTime   = time;
   req.mCurrentTime = 0;
   requests.push_back(req);

   return req.mJobId;
}

/// \fn ScriptManager::unschedule(uint jobid)
/// \brief Removes a job from the request list.
void ScriptManager::unschedule(uint jobid)
{
   Requests::iterator it = requests.begin();
   for ( ; it != requests.end(); ++it )
   {
      Request& request = *it;
      if ( request.mJobId == jobid)
      {
         requests.erase(it);
         break;
      }
   }
}

/// \fn ScriptManager::unscheduleAll()
/// \brief Removes all requests from the list.
void ScriptManager::unscheduleAll()
{
   requests.clear();
}

//-----------------------------------------
// - Function interface
//-----------------------------------------

bool ScriptManager::hasFunction(const std::string& name) const
{
   lua_pushstring(luaState, name.c_str());
   lua_rawget(luaState, LUA_GLOBALSINDEX);
   bool res = lua_isfunction(luaState, -1);
   lua_pop(luaState, 1);

   return res;
}

std::string ScriptManager::generateUniqueFunctionName(const std::string& name)
{
   int index = 0;
   std::ostringstream uniquename;

   uniquename << name;

   while ( hasFunction(uniquename.str()) )
   {
      uniquename.clear();
      uniquename << name << index;
   }

   return uniquename.str();
}

//-----------------------------------------
// - Global retreival
//-----------------------------------------

int ScriptManager::getInt(const char* var)
{
   lua_getglobal(luaState, var);
   if (!lua_isnumber(luaState, -1))
      return -1;
   else
      return (int)lua_tonumber(luaState, -1);
}

bool ScriptManager::getBool(const char* var)
{
   lua_getglobal(luaState, var);
   return (bool)lua_toboolean(luaState, -1);
}

void* ScriptManager::getClass(const char* var)
{
   lua_getglobal(luaState, var);
   return *((void**)lua_touserdata(luaState,-1));
}
