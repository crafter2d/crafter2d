/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : F:\\Devel\\crafter2d\\tools\\yasc\\yas.g
 *     -                            On : 2014-08-14 17:28:41
 *     -                 for the lexer : yasLexerLexer
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "yasLexer.h"
/* ----------------------------------------- */


/** String literals used by yasLexer that we must do things like MATCHS() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
static ANTLR3_UCHAR	lit_1[]  = { 0x2B, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_2[]  = { 0x2D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_3[]  = { 0x70, 0x61, 0x63, 0x6B, 0x61, 0x67, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_4[]  = { 0x75, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_5[]  = { 0x63, 0x6C, 0x61, 0x73, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_6[]  = { 0x69, 0x6E, 0x74, 0x65, 0x72, 0x66, 0x61, 0x63, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_7[]  = { 0x73, 0x75, 0x70, 0x65, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_8[]  = { 0x74, 0x68, 0x69, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_9[]  = { 0x65, 0x78, 0x74, 0x65, 0x6E, 0x64, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_10[]  = { 0x69, 0x6D, 0x70, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x73,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_11[]  = { 0x6E, 0x65, 0x77,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_12[]  = { 0x69, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x6F, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_13[]  = { 0x61, 0x73, 0x73, 0x65, 0x72, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_14[]  = { 0x70, 0x72, 0x6F, 0x70, 0x65, 0x72, 0x74, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_15[]  = { 0x66, 0x6F, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_16[]  = { 0x66, 0x6F, 0x72, 0x65, 0x61, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_17[]  = { 0x77, 0x68, 0x69, 0x6C, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_18[]  = { 0x64, 0x6F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_19[]  = { 0x73, 0x77, 0x69, 0x74, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_20[]  = { 0x63, 0x61, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_21[]  = { 0x64, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_22[]  = { 0x62, 0x72, 0x65, 0x61, 0x6B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_23[]  = { 0x63, 0x6F, 0x6E, 0x74, 0x69, 0x6E, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_24[]  = { 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_25[]  = { 0x69, 0x66,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_26[]  = { 0x65, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_27[]  = { 0x74, 0x72, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_28[]  = { 0x63, 0x61, 0x74, 0x63, 0x68,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_29[]  = { 0x66, 0x69, 0x6E, 0x61, 0x6C, 0x6C, 0x79,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_30[]  = { 0x74, 0x68, 0x72, 0x6F, 0x77,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_31[]  = { 0x6E, 0x75, 0x6C, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_32[]  = { 0x74, 0x72, 0x75, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_33[]  = { 0x66, 0x61, 0x6C, 0x73, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_34[]  = { 0x26, 0x26,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_35[]  = { 0x7C, 0x7C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_36[]  = { 0x2B, 0x2B,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_37[]  = { 0x2D, 0x2D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_38[]  = { 0x3D, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_39[]  = { 0x21, 0x3D,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_40[]  = { 0x63, 0x68, 0x61, 0x72,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_41[]  = { 0x69, 0x6E, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_42[]  = { 0x72, 0x65, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_43[]  = { 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_44[]  = { 0x62, 0x6F, 0x6F, 0x6C, 0x65, 0x61, 0x6E,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_45[]  = { 0x76, 0x6F, 0x69, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_46[]  = { 0x73, 0x74, 0x61, 0x74, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_47[]  = { 0x66, 0x69, 0x6E, 0x61, 0x6C,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_48[]  = { 0x61, 0x62, 0x73, 0x74, 0x72, 0x61, 0x63, 0x74,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_49[]  = { 0x6E, 0x61, 0x74, 0x69, 0x76, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_50[]  = { 0x73, 0x79, 0x6E, 0x63, 0x68, 0x72, 0x6F, 0x6E, 0x69, 0x7A, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_51[]  = { 0x70, 0x75, 0x62, 0x6C, 0x69, 0x63,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_52[]  = { 0x70, 0x72, 0x6F, 0x74, 0x65, 0x63, 0x74, 0x65, 0x64,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_53[]  = { 0x70, 0x72, 0x69, 0x76, 0x61, 0x74, 0x65,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_54[]  = { 0x2F, 0x2A,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_55[]  = { 0x2A, 0x2F,  ANTLR3_STRING_TERMINATOR};
static ANTLR3_UCHAR	lit_56[]  = { 0x2F, 0x2F,  ANTLR3_STRING_TERMINATOR};





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pyasLexer_##scope##_SCOPE
#define SCOPE_STACK(scope)  pyasLexer_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pyasLexer_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pyasLexer_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))


/* Macros for accessing things in a lexer
 */
#undef	    LEXER
#undef	    RECOGNIZER
#undef	    RULEMEMO
#undef	    GETCHARINDEX
#undef	    GETLINE
#undef	    GETCHARPOSITIONINLINE
#undef	    EMIT
#undef	    EMITNEW
#undef	    MATCHC
#undef	    MATCHS
#undef	    MATCHRANGE
#undef	    LTOKEN
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    INPUT
#undef	    STRSTREAM
#undef	    LA
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    LRECOVER
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    BACKTRACKING
#undef		MATCHANY
#undef		MEMOIZE
#undef		HAVEPARSEDRULE
#undef		GETTEXT
#undef		INDEX
#undef		SEEK
#undef		PUSHSTREAM
#undef		POPSTREAM
#undef		SETTEXT
#undef		SETTEXT8

#define	    LEXER					ctx->pLexer
#define	    RECOGNIZER			    LEXER->rec
#define		LEXSTATE				RECOGNIZER->state
#define		TOKSOURCE				LEXSTATE->tokSource
#define	    GETCHARINDEX()			LEXER->getCharIndex(LEXER)
#define	    GETLINE()				LEXER->getLine(LEXER)
#define	    GETTEXT()				LEXER->getText(LEXER)
#define	    GETCHARPOSITIONINLINE() LEXER->getCharPositionInLine(LEXER)
#define	    EMIT()					LEXSTATE->type = _type; LEXER->emit(LEXER)
#define	    EMITNEW(t)				LEXER->emitNew(LEXER, t)
#define	    MATCHC(c)				LEXER->matchc(LEXER, c)
#define	    MATCHS(s)				LEXER->matchs(LEXER, s)
#define	    MATCHRANGE(c1,c2)	    LEXER->matchRange(LEXER, c1, c2)
#define	    MATCHANY()				LEXER->matchAny(LEXER)
#define	    LTOKEN  				LEXSTATE->token
#define	    HASFAILED()				(LEXSTATE->failed == ANTLR3_TRUE)
#define	    BACKTRACKING			LEXSTATE->backtracking
#define	    FAILEDFLAG				LEXSTATE->failed
#define	    INPUT					LEXER->input
#define	    STRSTREAM				INPUT
#define		ISTREAM					INPUT->istream
#define		INDEX()					ISTREAM->index(ISTREAM)
#define		SEEK(n)					ISTREAM->seek(ISTREAM, n)
#define	    EOF_TOKEN				&(LEXSTATE->tokSource->eofToken)
#define	    HASEXCEPTION()			(LEXSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				LEXSTATE->exception
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    LRECOVER()				LEXER->recover(LEXER)
#define	    MARK()					ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define		MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define		HAVEPARSEDRULE(r)		RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		PUSHSTREAM(str)			LEXER->pushCharStream(LEXER, str)
#define		POPSTREAM()				LEXER->popCharStream(LEXER)
#define		SETTEXT(str)			LEXSTATE->text = str
#define		SKIP()					LEXSTATE->token = &(TOKSOURCE->skipToken)
#define		USER1					LEXSTATE->user1
#define		USER2					LEXSTATE->user2
#define		USER3					LEXSTATE->user3
#define		CUSTOM					LEXSTATE->custom
#define		RULEMEMO				LEXSTATE->ruleMemo
#define		DBG						RECOGNIZER->debugger

/* If we have been told we can rely on the standard 8 bit or UTF16 input
 * stream, then we can define our macros to use the direct pointers
 * in the input object, which is much faster than indirect calls. This
 * is really only significant to lexers with a lot of fragment rules (which
 * do not place LA(1) in a temporary at the moment) and even then
 * only if there is a lot of input (order of say 1M or so).
 */
#if	defined(ANTLR3_INLINE_INPUT_8BIT) || defined(ANTLR3_INLINE_INPUT_UTF16)

# ifdef	ANTLR3_INLINE_INPUT_8BIT

/* 8 bit character set */

#  define	    NEXTCHAR	((pANTLR3_UINT8)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT8)(INPUT->data))

# else

#  define	    NEXTCHAR	((pANTLR3_UINT16)(INPUT->nextChar))
#  define	    DATAP	((pANTLR3_UINT16)(INPUT->data))

# endif

# define	    LA(n) ((NEXTCHAR + n) > (DATAP + INPUT->sizeBuf) ? ANTLR3_CHARSTREAM_EOF : (ANTLR3_UCHAR)(*(NEXTCHAR + n - 1)))
# define            CONSUME()                                           \
{                                                                       \
    if        (NEXTCHAR < (DATAP + INPUT->sizeBuf))                     \
    {                                                                   \
        INPUT->charPositionInLine++;                                    \
        if  ((ANTLR3_UCHAR)(*NEXTCHAR) == INPUT->newlineChar)           \
        {                                                               \
            INPUT->line++;                                              \
            INPUT->charPositionInLine        = 0;                       \
            INPUT->currentLine                = (void *)(NEXTCHAR + 1); \
        }                                                               \
        INPUT->nextChar = (void *)(NEXTCHAR + 1);                       \
    }                                                                   \
}

#else

// Pick up the input character by calling the input stream implementation.
//
#define	    CONSUME()   INPUT->istream->consume(INPUT->istream)
#define	    LA(n)       INPUT->istream->_LA(INPUT->istream, n)

#endif

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

/* Forward declare the locally static matching functions we have generated and any predicate functions.
 */
static ANTLR3_INLINE 
 void
	mT__116    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__117    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__118    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__119    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__120    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__121    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__122    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__123    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__124    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__125    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__126    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__127    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT__128    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_PACKAGE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mUSE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mCLASS    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mINTRFACE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSUPER    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mTHIS    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mEXTENDS    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mIMPL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mNEW    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mINST_OF    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_ASSERT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mPROPERTY    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mFOR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mFOREACH    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mWHILE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mDO    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSWITCH    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mCASE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mDEFAULT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mBREAK    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mCONTINUE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mRETURN    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mIF    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mELSE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mTRY    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mCATCH    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mFINALLY    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mTHROW    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mLITNULL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mLITTRUE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mLITFALSE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mAND    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mOR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mMUL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mDIV    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mREM    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mPLUS    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mMINUS    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mBITCOMPL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mNOT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mBITAND    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mBITOR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mBITXOR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mINCR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mDECR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mEQUAL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mUNEQUAL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSEQUAL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSMALLER    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mGREATER    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mGEQUAL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSHIFTL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSHIFTR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_CHAR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_INT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_REAL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_STRING    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_BOOL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mT_VOID    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSTATIC    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mFINAL    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mABSTRACT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mNATIVE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSYNC    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mPUBLIC    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mPROT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mPRIVATE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSEP    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mID    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mINT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mFLOAT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mWHITESPACE    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mSTRING    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mCHAR    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mCOMMENT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mLINE_COMMENT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mEXPONENT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mHEX_DIGIT    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mESC_SEQ    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mOCTAL_ESC    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mUNICODE_ESC    (pyasLexer ctx);
static ANTLR3_INLINE 
 void
	mTokens    (pyasLexer ctx);
static void	yasLexerFree(pyasLexer ctx);

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */



static void
yasLexerFree  (pyasLexer ctx)
{
    LEXER->free(LEXER);

    ANTLR3_FREE(ctx);
}

static void
yasLexerReset (pyasLexer ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "F:\\Devel\\crafter2d\\tools\\yasc\\yas.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}

/** \brief Create a new lexer called yasLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \return
 *     - Success pyasLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pyasLexer yasLexerNew
(
pANTLR3_INPUT_STREAM
 instream)
{
	// See if we can create a new lexer with the standard constructor
	//
	return yasLexerNewSSD(instream, NULL);
}

/** \brief Create a new lexer called yasLexer
 *
 * \param[in]    instream Pointer to an initialized input stream
 * \param[state] state Previously created shared recognizer stat
 * \return
 *     - Success pyasLexer initialized for the lex start
 *     - Fail NULL
 */
ANTLR3_API pyasLexer yasLexerNewSSD
(pANTLR3_INPUT_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pyasLexer ctx; // Context structure we will build and return

    ctx = (pyasLexer) ANTLR3_CALLOC(1, sizeof(yasLexer));

    if  (ctx == NULL)
    {
        // Failed to allocate memory for lexer context
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in yasLexer.h here so you can get a sense
     * of what goes where.
     */

    /* Create a base lexer, using the supplied input stream
     */
    ctx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Check that we allocated the memory correctly
     */
    if	(ctx->pLexer == NULL)
    {
		ANTLR3_FREE(ctx);
		return  NULL;
    }
    /* Install the implementation of our yasLexer interface
     */
    ctx->mT__116	= mT__116;
    ctx->mT__117	= mT__117;
    ctx->mT__118	= mT__118;
    ctx->mT__119	= mT__119;
    ctx->mT__120	= mT__120;
    ctx->mT__121	= mT__121;
    ctx->mT__122	= mT__122;
    ctx->mT__123	= mT__123;
    ctx->mT__124	= mT__124;
    ctx->mT__125	= mT__125;
    ctx->mT__126	= mT__126;
    ctx->mT__127	= mT__127;
    ctx->mT__128	= mT__128;
    ctx->mT_PACKAGE	= mT_PACKAGE;
    ctx->mUSE	= mUSE;
    ctx->mCLASS	= mCLASS;
    ctx->mINTRFACE	= mINTRFACE;
    ctx->mSUPER	= mSUPER;
    ctx->mTHIS	= mTHIS;
    ctx->mEXTENDS	= mEXTENDS;
    ctx->mIMPL	= mIMPL;
    ctx->mNEW	= mNEW;
    ctx->mINST_OF	= mINST_OF;
    ctx->mT_ASSERT	= mT_ASSERT;
    ctx->mPROPERTY	= mPROPERTY;
    ctx->mFOR	= mFOR;
    ctx->mFOREACH	= mFOREACH;
    ctx->mWHILE	= mWHILE;
    ctx->mDO	= mDO;
    ctx->mSWITCH	= mSWITCH;
    ctx->mCASE	= mCASE;
    ctx->mDEFAULT	= mDEFAULT;
    ctx->mBREAK	= mBREAK;
    ctx->mCONTINUE	= mCONTINUE;
    ctx->mRETURN	= mRETURN;
    ctx->mIF	= mIF;
    ctx->mELSE	= mELSE;
    ctx->mTRY	= mTRY;
    ctx->mCATCH	= mCATCH;
    ctx->mFINALLY	= mFINALLY;
    ctx->mTHROW	= mTHROW;
    ctx->mLITNULL	= mLITNULL;
    ctx->mLITTRUE	= mLITTRUE;
    ctx->mLITFALSE	= mLITFALSE;
    ctx->mAND	= mAND;
    ctx->mOR	= mOR;
    ctx->mMUL	= mMUL;
    ctx->mDIV	= mDIV;
    ctx->mREM	= mREM;
    ctx->mPLUS	= mPLUS;
    ctx->mMINUS	= mMINUS;
    ctx->mBITCOMPL	= mBITCOMPL;
    ctx->mNOT	= mNOT;
    ctx->mBITAND	= mBITAND;
    ctx->mBITOR	= mBITOR;
    ctx->mBITXOR	= mBITXOR;
    ctx->mINCR	= mINCR;
    ctx->mDECR	= mDECR;
    ctx->mEQUAL	= mEQUAL;
    ctx->mUNEQUAL	= mUNEQUAL;
    ctx->mSEQUAL	= mSEQUAL;
    ctx->mSMALLER	= mSMALLER;
    ctx->mGREATER	= mGREATER;
    ctx->mGEQUAL	= mGEQUAL;
    ctx->mSHIFTL	= mSHIFTL;
    ctx->mSHIFTR	= mSHIFTR;
    ctx->mT_CHAR	= mT_CHAR;
    ctx->mT_INT	= mT_INT;
    ctx->mT_REAL	= mT_REAL;
    ctx->mT_STRING	= mT_STRING;
    ctx->mT_BOOL	= mT_BOOL;
    ctx->mT_VOID	= mT_VOID;
    ctx->mSTATIC	= mSTATIC;
    ctx->mFINAL	= mFINAL;
    ctx->mABSTRACT	= mABSTRACT;
    ctx->mNATIVE	= mNATIVE;
    ctx->mSYNC	= mSYNC;
    ctx->mPUBLIC	= mPUBLIC;
    ctx->mPROT	= mPROT;
    ctx->mPRIVATE	= mPRIVATE;
    ctx->mSEP	= mSEP;
    ctx->mID	= mID;
    ctx->mINT	= mINT;
    ctx->mFLOAT	= mFLOAT;
    ctx->mWHITESPACE	= mWHITESPACE;
    ctx->mSTRING	= mSTRING;
    ctx->mCHAR	= mCHAR;
    ctx->mCOMMENT	= mCOMMENT;
    ctx->mLINE_COMMENT	= mLINE_COMMENT;
    ctx->mEXPONENT	= mEXPONENT;
    ctx->mHEX_DIGIT	= mHEX_DIGIT;
    ctx->mESC_SEQ	= mESC_SEQ;
    ctx->mOCTAL_ESC	= mOCTAL_ESC;
    ctx->mUNICODE_ESC	= mUNICODE_ESC;
    ctx->mTokens	= mTokens;

    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    ctx->pLexer->ctx	    = ctx;

    /**Install the token matching function
     */
    ctx->pLexer->mTokens = (void (*) (void *))(mTokens);

    ctx->getGrammarFileName	= getGrammarFileName;
    ctx->free		= yasLexerFree;
    ctx->reset          = yasLexerReset;


    /* Return the newly built lexer to the caller
     */
    return  ctx;
}

/* =========================================================================
 * DFA tables for the lexer
 */
/** Static dfa state tables for Cyclic dfa:
 *    484:1: FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );
 */
static const ANTLR3_INT32 dfa9_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_eof[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_min[5] =
    {
	46, 46, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_max[5] =
    {
	57, 101, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_accept[5] =
    {
	-1, -1, 2, 1, 3
    };
static const ANTLR3_INT32 dfa9_special[5] =
    {
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa9_T_empty	    NULL

static const ANTLR3_INT32 dfa9_T0[] =
    {
	3, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };

static const ANTLR3_INT32 dfa9_T1[] =
    {
	2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa9_transitions[] =
{
    dfa9_T1, dfa9_T0, NULL, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 9
 */
static
ANTLR3_CYCLIC_DFA cdfa9
    =	{
	    9,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"484:1: FLOAT : ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa9_eot,	    /* EOT table			    */
	    dfa9_eof,	    /* EOF table			    */
	    dfa9_min,	    /* Minimum tokens for each state    */
	    dfa9_max,	    /* Maximum tokens for each state    */
	    dfa9_accept,	/* Accept table			    */
	    dfa9_special,	/* Special transition states	    */
	    dfa9_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 9
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    1:1: Tokens : ( T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T_PACKAGE | USE | CLASS | INTRFACE | SUPER | THIS | EXTENDS | IMPL | NEW | INST_OF | T_ASSERT | PROPERTY | FOR | FOREACH | WHILE | DO | SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN | IF | ELSE | TRY | CATCH | FINALLY | THROW | LITNULL | LITTRUE | LITFALSE | AND | OR | MUL | DIV | REM | PLUS | MINUS | BITCOMPL | NOT | BITAND | BITOR | BITXOR | INCR | DECR | EQUAL | UNEQUAL | SEQUAL | SMALLER | GREATER | GEQUAL | SHIFTL | SHIFTR | T_CHAR | T_INT | T_REAL | T_STRING | T_BOOL | T_VOID | STATIC | FINAL | ABSTRACT | NATIVE | SYNC | PUBLIC | PROT | PRIVATE | SEP | ID | INT | FLOAT | WHITESPACE | STRING | CHAR | COMMENT | LINE_COMMENT );
 */
static const ANTLR3_INT32 dfa20_eot[310] =
    {
	-1, -1, -1, 47, -1, 50, 51, -1, 54, -1, -1, -1, -1, -1, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 89, 91, -1, 94, -1, -1, 96, -1, 
	99, 102, 40, -1, -1, 104, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 118, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 139, 40, 40, 40, 40, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 40, -1, 40, 40, 40, 
	40, 151, 40, 40, 40, 40, 40, 158, 40, 40, -1, 40, 40, 40, 40, 40, 40, 40, 
	168, 40, 40, 40, 172, 40, 40, 40, 40, 178, 40, 40, 40, -1, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, -1, 40, 194, 40, 40, 197, 40, -1, 40, 40, 
	40, 40, 40, 40, 40, 206, 40, -1, 208, 40, 210, -1, 211, 40, 40, 40, 40, 
	-1, 40, 40, 40, 40, 40, 40, 40, 223, 224, 40, 40, 40, 40, 40, 230, -1, 
	231, 40, -1, 40, 40, 40, 236, 40, 40, 40, 40, -1, 241, -1, 40, -1, -1, 
	40, 40, 40, 40, 248, 249, 250, 40, 252, 40, 40, -1, -1, 40, 40, 40, 40, 
	259, -1, -1, 40, 40, 40, 40, -1, 264, 265, 266, 40, -1, 40, 269, 270, 40, 
	40, 40, -1, -1, -1, 40, -1, 40, 276, 277, 40, 40, 280, -1, 40, 40, 40, 
	40, -1, -1, -1, 40, 286, -1, -1, 40, 288, 289, 290, 291, -1, -1, 292, 40, 
	-1, 294, 40, 40, 40, 40, -1, 299, -1, -1, -1, -1, -1, 300, -1, 301, 40, 
	40, 40, -1, -1, -1, 305, 306, 40, -1, -1, 40, 309, -1
    };
static const ANTLR3_INT32 dfa20_eof[310] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa20_min[310] =
    {
	9, -1, -1, 43, -1, 45, 48, -1, 61, -1, -1, -1, -1, -1, 97, 115, 97, 102, 
	116, 104, 108, 97, 98, 97, 104, 101, 111, 101, 38, 124, -1, 42, -1, -1, 
	61, -1, 60, 61, 111, -1, -1, 46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 99, 105, 98, 101, 97, 115, 110, 97, 115, 112, 48, 112, 105, 
	97, 110, 105, 117, 116, 115, 119, 108, 116, 115, 115, 114, 110, 108, 105, 
	48, 102, 101, 111, 97, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 105, -1, 107, 112, 118, 108, 48, 115, 101, 99, 116, 114, 48, 
	116, 108, -1, 101, 116, 105, 116, 99, 115, 111, 48, 101, 101, 101, 48, 
	108, 105, 101, 116, 48, 97, 115, 108, -1, 97, 97, 108, 117, 108, 100, 97, 
	101, 101, 97, 105, -1, 115, 48, 104, 105, 48, 114, -1, 97, 101, 114, 99, 
	110, 105, 104, 48, 119, -1, 48, 110, 48, -1, 48, 118, 114, 114, 97, -1, 
	108, 101, 101, 117, 107, 101, 114, 48, 48, 103, 114, 99, 116, 99, 48, -1, 
	48, 110, -1, 102, 110, 109, 48, 104, 103, 99, 114, -1, 48, -1, 100, -1, 
	-1, 101, 116, 97, 99, 48, 48, 48, 108, 48, 97, 110, -1, -1, 101, 116, 116, 
	101, 48, -1, -1, 117, 97, 99, 101, -1, 48, 48, 48, 111, -1, 115, 48, 48, 
	99, 104, 121, -1, -1, -1, 116, -1, 110, 48, 48, 121, 101, 48, -1, 101, 
	99, 101, 110, -1, -1, -1, 110, 48, -1, -1, 116, 48, 48, 48, 48, -1, -1, 
	48, 100, -1, 48, 101, 111, 116, 105, -1, 48, -1, -1, -1, -1, -1, 48, -1, 
	48, 102, 115, 122, -1, -1, -1, 48, 48, 101, -1, -1, 100, 48, -1
    };
static const ANTLR3_INT32 dfa20_max[310] =
    {
	126, -1, -1, 61, -1, 61, 57, -1, 61, -1, -1, -1, -1, -1, 117, 115, 111, 
	110, 121, 114, 120, 117, 115, 111, 104, 111, 114, 101, 38, 124, -1, 47, 
	-1, -1, 61, -1, 61, 62, 111, -1, -1, 101, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 99, 111, 98, 101, 97, 116, 110, 97, 116, 112, 122, 
	112, 105, 114, 110, 114, 121, 116, 115, 119, 108, 116, 115, 115, 114, 110, 
	108, 105, 122, 102, 101, 111, 116, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 105, -1, 107, 116, 118, 108, 122, 115, 101, 99, 
	116, 114, 122, 116, 108, -1, 101, 116, 105, 116, 99, 115, 111, 122, 101, 
	101, 101, 122, 108, 105, 101, 116, 122, 97, 115, 108, -1, 97, 97, 108, 
	117, 108, 100, 97, 101, 101, 97, 105, -1, 115, 122, 104, 105, 122, 114, 
	-1, 97, 101, 114, 99, 110, 105, 104, 122, 119, -1, 122, 110, 122, -1, 122, 
	118, 114, 114, 97, -1, 108, 101, 101, 117, 107, 101, 114, 122, 122, 103, 
	114, 99, 116, 99, 122, -1, 122, 110, -1, 102, 110, 109, 122, 104, 103, 
	99, 114, -1, 122, -1, 100, -1, -1, 101, 116, 97, 99, 122, 122, 122, 108, 
	122, 97, 110, -1, -1, 101, 116, 116, 101, 122, -1, -1, 117, 97, 99, 101, 
	-1, 122, 122, 122, 111, -1, 115, 122, 122, 99, 104, 121, -1, -1, -1, 116, 
	-1, 110, 122, 122, 121, 101, 122, -1, 101, 99, 101, 110, -1, -1, -1, 110, 
	122, -1, -1, 116, 122, 122, 122, 122, -1, -1, 122, 100, -1, 122, 101, 111, 
	116, 105, -1, 122, -1, -1, -1, -1, -1, 122, -1, 122, 102, 115, 122, -1, 
	-1, -1, 122, 122, 101, -1, -1, 100, 122, -1
    };
static const ANTLR3_INT32 dfa20_accept[310] =
    {
	-1, 1, 2, -1, 4, -1, -1, 7, -1, 9, 10, 11, 12, 13, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 47, -1, 49, 52, -1, 56, -1, 
	-1, -1, 81, 82, -1, 85, 86, 87, 3, 57, 50, 5, 58, 51, 6, 84, 59, 8, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 45, 54, 46, 55, 
	88, 89, 48, 60, 53, 61, 65, 62, 64, 66, 63, -1, 83, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 29, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 15, -1, -1, -1, -1, -1, -1, 68, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 38, -1, -1, -1, 22, -1, -1, -1, -1, -1, 26, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 31, -1, -1, 67, -1, -1, 
	-1, -1, -1, -1, -1, -1, 19, -1, 43, -1, 37, 42, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 69, 72, -1, -1, -1, -1, -1, 16, 39, -1, -1, -1, -1, 
	18, -1, -1, -1, -1, 41, -1, -1, -1, -1, -1, -1, 74, 44, 28, -1, 33, -1, 
	-1, -1, -1, -1, -1, 78, -1, -1, -1, -1, 30, 70, 73, -1, -1, 76, 24, -1, 
	-1, -1, -1, -1, 35, 14, -1, -1, 80, -1, -1, -1, -1, -1, 20, -1, 27, 40, 
	32, 71, 25, -1, 34, -1, -1, -1, -1, 75, 79, 17, -1, -1, -1, 23, 21, -1, 
	-1, 77
    };
static const ANTLR3_INT32 dfa20_special[310] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa20_T_empty	    NULL

static const ANTLR3_INT32 dfa20_T0[] =
    {
	86, -1, -1, 85
    };

static const ANTLR3_INT32 dfa20_T1[] =
    {
	193
    };

static const ANTLR3_INT32 dfa20_T2[] =
    {
	110
    };

static const ANTLR3_INT32 dfa20_T3[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };

static const ANTLR3_INT32 dfa20_T4[] =
    {
	152
    };

static const ANTLR3_INT32 dfa20_T5[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 157, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };

static const ANTLR3_INT32 dfa20_T6[] =
    {
	255
    };

static const ANTLR3_INT32 dfa20_T7[] =
    {
	109
    };

static const ANTLR3_INT32 dfa20_T8[] =
    {
	87
    };

static const ANTLR3_INT32 dfa20_T9[] =
    {
	225
    };

static const ANTLR3_INT32 dfa20_T10[] =
    {
	188
    };

static const ANTLR3_INT32 dfa20_T11[] =
    {
	146
    };

static const ANTLR3_INT32 dfa20_T12[] =
    {
	105
    };

static const ANTLR3_INT32 dfa20_T13[] =
    {
	111, 112
    };

static const ANTLR3_INT32 dfa20_T14[] =
    {
	166
    };

static const ANTLR3_INT32 dfa20_T15[] =
    {
	128
    };

static const ANTLR3_INT32 dfa20_T16[] =
    {
	119
    };

static const ANTLR3_INT32 dfa20_T17[] =
    {
	161
    };

static const ANTLR3_INT32 dfa20_T18[] =
    {
	201
    };

static const ANTLR3_INT32 dfa20_T19[] =
    {
	282
    };

static const ANTLR3_INT32 dfa20_T20[] =
    {
	261
    };

static const ANTLR3_INT32 dfa20_T21[] =
    {
	295
    };

static const ANTLR3_INT32 dfa20_T22[] =
    {
	233
    };

static const ANTLR3_INT32 dfa20_T23[] =
    {
	49, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 48
    };

static const ANTLR3_INT32 dfa20_T24[] =
    {
	100, 101
    };

static const ANTLR3_INT32 dfa20_T25[] =
    {
	198
    };

static const ANTLR3_INT32 dfa20_T26[] =
    {
	82
    };

static const ANTLR3_INT32 dfa20_T27[] =
    {
	46, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	45
    };

static const ANTLR3_INT32 dfa20_T28[] =
    {
	78, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 77
    };

static const ANTLR3_INT32 dfa20_T29[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 177, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };

static const ANTLR3_INT32 dfa20_T30[] =
    {
	190
    };

static const ANTLR3_INT32 dfa20_T31[] =
    {
	257
    };

static const ANTLR3_INT32 dfa20_T32[] =
    {
	227
    };

static const ANTLR3_INT32 dfa20_T33[] =
    {
	293
    };

static const ANTLR3_INT32 dfa20_T34[] =
    {
	162
    };

static const ANTLR3_INT32 dfa20_T35[] =
    {
	279
    };

static const ANTLR3_INT32 dfa20_T36[] =
    {
	120
    };

static const ANTLR3_INT32 dfa20_T37[] =
    {
	135
    };

static const ANTLR3_INT32 dfa20_T38[] =
    {
	237
    };

static const ANTLR3_INT32 dfa20_T39[] =
    {
	202
    };

static const ANTLR3_INT32 dfa20_T40[] =
    {
	149
    };

static const ANTLR3_INT32 dfa20_T41[] =
    {
	191
    };

static const ANTLR3_INT32 dfa20_T42[] =
    {
	228
    };

static const ANTLR3_INT32 dfa20_T43[] =
    {
	258
    };

static const ANTLR3_INT32 dfa20_T44[] =
    {
	116, 115
    };

static const ANTLR3_INT32 dfa20_T45[] =
    {
	60, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 59, -1, -1, 61
    };

static const ANTLR3_INT32 dfa20_T46[] =
    {
	246
    };

static const ANTLR3_INT32 dfa20_T47[] =
    {
	272
    };

static const ANTLR3_INT32 dfa20_T48[] =
    {
	215
    };

static const ANTLR3_INT32 dfa20_T49[] =
    {
	181
    };

static const ANTLR3_INT32 dfa20_T50[] =
    {
	218
    };

static const ANTLR3_INT32 dfa20_T51[] =
    {
	138
    };

static const ANTLR3_INT32 dfa20_T52[] =
    {
	174
    };

static const ANTLR3_INT32 dfa20_T53[] =
    {
	132
    };

static const ANTLR3_INT32 dfa20_T54[] =
    {
	68, 66, -1, 67, -1, 69
    };

static const ANTLR3_INT32 dfa20_T55[] =
    {
	183
    };

static const ANTLR3_INT32 dfa20_T56[] =
    {
	141
    };

static const ANTLR3_INT32 dfa20_T57[] =
    {
	243
    };

static const ANTLR3_INT32 dfa20_T58[] =
    {
	212
    };

static const ANTLR3_INT32 dfa20_T59[] =
    {
	220
    };

static const ANTLR3_INT32 dfa20_T60[] =
    {
	123
    };

static const ANTLR3_INT32 dfa20_T61[] =
    {
	267
    };

static const ANTLR3_INT32 dfa20_T62[] =
    {
	155
    };

static const ANTLR3_INT32 dfa20_T63[] =
    {
	240
    };

static const ANTLR3_INT32 dfa20_T64[] =
    {
	113
    };

static const ANTLR3_INT32 dfa20_T65[] =
    {
	232
    };

static const ANTLR3_INT32 dfa20_T66[] =
    {
	205
    };

static const ANTLR3_INT32 dfa20_T67[] =
    {
	165
    };

static const ANTLR3_INT32 dfa20_T68[] =
    {
	196
    };

static const ANTLR3_INT32 dfa20_T69[] =
    {
	304
    };

static const ANTLR3_INT32 dfa20_T70[] =
    {
	307
    };

static const ANTLR3_INT32 dfa20_T71[] =
    {
	285
    };

static const ANTLR3_INT32 dfa20_T72[] =
    {
	298
    };

static const ANTLR3_INT32 dfa20_T73[] =
    {
	107, -1, -1, -1, -1, -1, 106
    };

static const ANTLR3_INT32 dfa20_T74[] =
    {
	153
    };

static const ANTLR3_INT32 dfa20_T75[] =
    {
	308
    };

static const ANTLR3_INT32 dfa20_T76[] =
    {
	70, -1, -1, -1, -1, -1, -1, -1, -1, -1, 71
    };

static const ANTLR3_INT32 dfa20_T77[] =
    {
	108
    };

static const ANTLR3_INT32 dfa20_T78[] =
    {
	150
    };

static const ANTLR3_INT32 dfa20_T79[] =
    {
	140
    };

static const ANTLR3_INT32 dfa20_T80[] =
    {
	182
    };

static const ANTLR3_INT32 dfa20_T81[] =
    {
	219
    };

static const ANTLR3_INT32 dfa20_T82[] =
    {
	251
    };

static const ANTLR3_INT32 dfa20_T83[] =
    {
	274
    };

static const ANTLR3_INT32 dfa20_T84[] =
    {
	192
    };

static const ANTLR3_INT32 dfa20_T85[] =
    {
	229
    };

static const ANTLR3_INT32 dfa20_T86[] =
    {
	130
    };

static const ANTLR3_INT32 dfa20_T87[] =
    {
	58
    };

static const ANTLR3_INT32 dfa20_T88[] =
    {
	303
    };

static const ANTLR3_INT32 dfa20_T89[] =
    {
	55, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 56, 
	-1, -1, 57
    };

static const ANTLR3_INT32 dfa20_T90[] =
    {
	234
    };

static const ANTLR3_INT32 dfa20_T91[] =
    {
	199
    };

static const ANTLR3_INT32 dfa20_T92[] =
    {
	159
    };

static const ANTLR3_INT32 dfa20_T93[] =
    {
	242
    };

static const ANTLR3_INT32 dfa20_T94[] =
    {
	268
    };

static const ANTLR3_INT32 dfa20_T95[] =
    {
	170
    };

static const ANTLR3_INT32 dfa20_T96[] =
    {
	209
    };

static const ANTLR3_INT32 dfa20_T97[] =
    {
	284
    };

static const ANTLR3_INT32 dfa20_T98[] =
    {
	297
    };

static const ANTLR3_INT32 dfa20_T99[] =
    {
	235
    };

static const ANTLR3_INT32 dfa20_T100[] =
    {
	263
    };

static const ANTLR3_INT32 dfa20_T101[] =
    {
	73, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 72
    };

static const ANTLR3_INT32 dfa20_T102[] =
    {
	160
    };

static const ANTLR3_INT32 dfa20_T103[] =
    {
	200
    };

static const ANTLR3_INT32 dfa20_T104[] =
    {
	95
    };

static const ANTLR3_INT32 dfa20_T105[] =
    {
	122, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 121
    };

static const ANTLR3_INT32 dfa20_T106[] =
    {
	117
    };

static const ANTLR3_INT32 dfa20_T107[] =
    {
	226
    };

static const ANTLR3_INT32 dfa20_T108[] =
    {
	189
    };

static const ANTLR3_INT32 dfa20_T109[] =
    {
	278
    };

static const ANTLR3_INT32 dfa20_T110[] =
    {
	256
    };

static const ANTLR3_INT32 dfa20_T111[] =
    {
	124, -1, -1, -1, -1, -1, -1, -1, -1, 125
    };

static const ANTLR3_INT32 dfa20_T112[] =
    {
	84, -1, -1, -1, -1, -1, -1, -1, -1, -1, 83
    };

static const ANTLR3_INT32 dfa20_T113[] =
    {
	262
    };

static const ANTLR3_INT32 dfa20_T114[] =
    {
	283
    };

static const ANTLR3_INT32 dfa20_T115[] =
    {
	296
    };

static const ANTLR3_INT32 dfa20_T116[] =
    {
	302
    };

static const ANTLR3_INT32 dfa20_T117[] =
    {
	244
    };

static const ANTLR3_INT32 dfa20_T118[] =
    {
	133
    };

static const ANTLR3_INT32 dfa20_T119[] =
    {
	175
    };

static const ANTLR3_INT32 dfa20_T120[] =
    {
	213
    };

static const ANTLR3_INT32 dfa20_T121[] =
    {
	156
    };

static const ANTLR3_INT32 dfa20_T122[] =
    {
	114
    };

static const ANTLR3_INT32 dfa20_T123[] =
    {
	147, -1, -1, -1, 148
    };

static const ANTLR3_INT32 dfa20_T124[] =
    {
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, -1, -1, -1, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, -1, -1, -1, -1, 40, -1, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 247, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40
    };

static const ANTLR3_INT32 dfa20_T125[] =
    {
	88
    };

static const ANTLR3_INT32 dfa20_T126[] =
    {
	42, 42, -1, 42, 42, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 42, 34, 43, -1, -1, 32, 28, 44, 1, 2, 30, 3, 4, 5, 
	6, 31, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 7, 39, 36, 8, 37, -1, 9, 
	40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 
	40, 40, 40, 40, 40, 40, 40, 40, 10, -1, 11, 35, 40, -1, 22, 26, 16, 25, 
	20, 23, 40, 40, 17, 40, 40, 40, 40, 21, 40, 14, 40, 27, 18, 19, 15, 38, 
	24, 40, 40, 40, 12, 29, 13, 33
    };

static const ANTLR3_INT32 dfa20_T127[] =
    {
	90
    };

static const ANTLR3_INT32 dfa20_T128[] =
    {
	81, -1, -1, -1, -1, -1, -1, -1, 80, -1, -1, -1, -1, -1, 79
    };

static const ANTLR3_INT32 dfa20_T129[] =
    {
	287
    };

static const ANTLR3_INT32 dfa20_T130[] =
    {
	271
    };

static const ANTLR3_INT32 dfa20_T131[] =
    {
	52, 52, 52, 52, 52, 52, 52, 52, 52, 52
    };

static const ANTLR3_INT32 dfa20_T132[] =
    {
	245
    };

static const ANTLR3_INT32 dfa20_T133[] =
    {
	214
    };

static const ANTLR3_INT32 dfa20_T134[] =
    {
	176
    };

static const ANTLR3_INT32 dfa20_T135[] =
    {
	134
    };

static const ANTLR3_INT32 dfa20_T136[] =
    {
	92, -1, -1, -1, -1, 93
    };

static const ANTLR3_INT32 dfa20_T137[] =
    {
	216
    };

static const ANTLR3_INT32 dfa20_T138[] =
    {
	204
    };

static const ANTLR3_INT32 dfa20_T139[] =
    {
	239
    };

static const ANTLR3_INT32 dfa20_T140[] =
    {
	164
    };

static const ANTLR3_INT32 dfa20_T141[] =
    {
	136
    };

static const ANTLR3_INT32 dfa20_T142[] =
    {
	179
    };

static const ANTLR3_INT32 dfa20_T143[] =
    {
	187
    };

static const ANTLR3_INT32 dfa20_T144[] =
    {
	145
    };

static const ANTLR3_INT32 dfa20_T145[] =
    {
	275
    };

static const ANTLR3_INT32 dfa20_T146[] =
    {
	103
    };

static const ANTLR3_INT32 dfa20_T147[] =
    {
	253
    };

static const ANTLR3_INT32 dfa20_T148[] =
    {
	142
    };

static const ANTLR3_INT32 dfa20_T149[] =
    {
	221
    };

static const ANTLR3_INT32 dfa20_T150[] =
    {
	184
    };

static const ANTLR3_INT32 dfa20_T151[] =
    {
	163
    };

static const ANTLR3_INT32 dfa20_T152[] =
    {
	203
    };

static const ANTLR3_INT32 dfa20_T153[] =
    {
	238
    };

static const ANTLR3_INT32 dfa20_T154[] =
    {
	186
    };

static const ANTLR3_INT32 dfa20_T155[] =
    {
	207
    };

static const ANTLR3_INT32 dfa20_T156[] =
    {
	167
    };

static const ANTLR3_INT32 dfa20_T157[] =
    {
	131
    };

static const ANTLR3_INT32 dfa20_T158[] =
    {
	173
    };

static const ANTLR3_INT32 dfa20_T159[] =
    {
	154
    };

static const ANTLR3_INT32 dfa20_T160[] =
    {
	195
    };

static const ANTLR3_INT32 dfa20_T161[] =
    {
	273
    };

static const ANTLR3_INT32 dfa20_T162[] =
    {
	127, -1, -1, -1, 126
    };

static const ANTLR3_INT32 dfa20_T163[] =
    {
	76, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 75
    };

static const ANTLR3_INT32 dfa20_T164[] =
    {
	129
    };

static const ANTLR3_INT32 dfa20_T165[] =
    {
	52, -1, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 52, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 52
    };

static const ANTLR3_INT32 dfa20_T166[] =
    {
	171
    };

static const ANTLR3_INT32 dfa20_T167[] =
    {
	65, -1, -1, -1, -1, -1, -1, 64, 63
    };

static const ANTLR3_INT32 dfa20_T168[] =
    {
	281
    };

static const ANTLR3_INT32 dfa20_T169[] =
    {
	260
    };

static const ANTLR3_INT32 dfa20_T170[] =
    {
	222
    };

static const ANTLR3_INT32 dfa20_T171[] =
    {
	185
    };

static const ANTLR3_INT32 dfa20_T172[] =
    {
	254
    };

static const ANTLR3_INT32 dfa20_T173[] =
    {
	98, 97
    };

static const ANTLR3_INT32 dfa20_T174[] =
    {
	53
    };

static const ANTLR3_INT32 dfa20_T175[] =
    {
	144, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 143
    };

static const ANTLR3_INT32 dfa20_T176[] =
    {
	169
    };

static const ANTLR3_INT32 dfa20_T177[] =
    {
	217
    };

static const ANTLR3_INT32 dfa20_T178[] =
    {
	180
    };

static const ANTLR3_INT32 dfa20_T179[] =
    {
	137
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa20_transitions[] =
{
    dfa20_T126, NULL, NULL, dfa20_T27, NULL, dfa20_T23, dfa20_T131, NULL, 
    dfa20_T174, NULL, NULL, NULL, NULL, NULL, dfa20_T89, dfa20_T87, dfa20_T45, 
    dfa20_T167, dfa20_T54, dfa20_T76, dfa20_T101, dfa20_T163, dfa20_T28, 
    dfa20_T128, dfa20_T26, dfa20_T112, dfa20_T0, dfa20_T8, dfa20_T125, dfa20_T127, 
    NULL, dfa20_T136, NULL, NULL, dfa20_T104, NULL, dfa20_T173, dfa20_T24, 
    dfa20_T146, NULL, NULL, dfa20_T165, NULL, NULL, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa20_T12, dfa20_T73, dfa20_T77, 
    dfa20_T7, dfa20_T2, dfa20_T13, dfa20_T64, dfa20_T122, dfa20_T44, dfa20_T106, 
    dfa20_T3, dfa20_T16, dfa20_T36, dfa20_T105, dfa20_T60, dfa20_T111, dfa20_T162, 
    dfa20_T15, dfa20_T164, dfa20_T86, dfa20_T157, dfa20_T53, dfa20_T118, 
    dfa20_T135, dfa20_T37, dfa20_T141, dfa20_T179, dfa20_T51, dfa20_T3, 
    dfa20_T79, dfa20_T56, dfa20_T148, dfa20_T175, NULL, NULL, NULL, NULL, 
    NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, dfa20_T144, 
    NULL, dfa20_T11, dfa20_T123, dfa20_T40, dfa20_T78, dfa20_T3, dfa20_T4, 
    dfa20_T74, dfa20_T159, dfa20_T62, dfa20_T121, dfa20_T5, dfa20_T92, dfa20_T102, 
    NULL, dfa20_T17, dfa20_T34, dfa20_T151, dfa20_T140, dfa20_T67, dfa20_T14, 
    dfa20_T156, dfa20_T3, dfa20_T176, dfa20_T95, dfa20_T166, dfa20_T3, dfa20_T158, 
    dfa20_T52, dfa20_T119, dfa20_T134, dfa20_T29, dfa20_T142, dfa20_T178, 
    dfa20_T49, NULL, dfa20_T80, dfa20_T55, dfa20_T150, dfa20_T171, dfa20_T154, 
    dfa20_T143, dfa20_T10, dfa20_T108, dfa20_T30, dfa20_T41, dfa20_T84, 
    NULL, dfa20_T1, dfa20_T3, dfa20_T160, dfa20_T68, dfa20_T3, dfa20_T25, 
    NULL, dfa20_T91, dfa20_T103, dfa20_T18, dfa20_T39, dfa20_T152, dfa20_T138, 
    dfa20_T66, dfa20_T3, dfa20_T155, NULL, dfa20_T3, dfa20_T96, dfa20_T3, 
    NULL, dfa20_T3, dfa20_T58, dfa20_T120, dfa20_T133, dfa20_T48, NULL, 
    dfa20_T137, dfa20_T177, dfa20_T50, dfa20_T81, dfa20_T59, dfa20_T149, 
    dfa20_T170, dfa20_T3, dfa20_T3, dfa20_T9, dfa20_T107, dfa20_T32, dfa20_T42, 
    dfa20_T85, dfa20_T3, NULL, dfa20_T3, dfa20_T65, NULL, dfa20_T22, dfa20_T90, 
    dfa20_T99, dfa20_T3, dfa20_T38, dfa20_T153, dfa20_T139, dfa20_T63, NULL, 
    dfa20_T3, NULL, dfa20_T93, NULL, NULL, dfa20_T57, dfa20_T117, dfa20_T132, 
    dfa20_T46, dfa20_T124, dfa20_T3, dfa20_T3, dfa20_T82, dfa20_T3, dfa20_T147, 
    dfa20_T172, NULL, NULL, dfa20_T6, dfa20_T110, dfa20_T31, dfa20_T43, 
    dfa20_T3, NULL, NULL, dfa20_T169, dfa20_T20, dfa20_T113, dfa20_T100, 
    NULL, dfa20_T3, dfa20_T3, dfa20_T3, dfa20_T61, NULL, dfa20_T94, dfa20_T3, 
    dfa20_T3, dfa20_T130, dfa20_T47, dfa20_T161, NULL, NULL, NULL, dfa20_T83, 
    NULL, dfa20_T145, dfa20_T3, dfa20_T3, dfa20_T109, dfa20_T35, dfa20_T3, 
    NULL, dfa20_T168, dfa20_T19, dfa20_T114, dfa20_T97, NULL, NULL, NULL, 
    dfa20_T71, dfa20_T3, NULL, NULL, dfa20_T129, dfa20_T3, dfa20_T3, dfa20_T3, 
    dfa20_T3, NULL, NULL, dfa20_T3, dfa20_T33, NULL, dfa20_T3, dfa20_T21, 
    dfa20_T115, dfa20_T98, dfa20_T72, NULL, dfa20_T3, NULL, NULL, NULL, 
    NULL, NULL, dfa20_T3, NULL, dfa20_T3, dfa20_T116, dfa20_T88, dfa20_T69, 
    NULL, NULL, NULL, dfa20_T3, dfa20_T3, dfa20_T70, NULL, NULL, dfa20_T75, 
    dfa20_T3, NULL
};


/* Declare tracking structure for Cyclic DFA 20
 */
static
ANTLR3_CYCLIC_DFA cdfa20
    =	{
	    20,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"1:1: Tokens : ( T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T_PACKAGE | USE | CLASS | INTRFACE | SUPER | THIS | EXTENDS | IMPL | NEW | INST_OF | T_ASSERT | PROPERTY | FOR | FOREACH | WHILE | DO | SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN | IF | ELSE | TRY | CATCH | FINALLY | THROW | LITNULL | LITTRUE | LITFALSE | AND | OR | MUL | DIV | REM | PLUS | MINUS | BITCOMPL | NOT | BITAND | BITOR | BITXOR | INCR | DECR | EQUAL | UNEQUAL | SEQUAL | SMALLER | GREATER | GEQUAL | SHIFTL | SHIFTR | T_CHAR | T_INT | T_REAL | T_STRING | T_BOOL | T_VOID | STATIC | FINAL | ABSTRACT | NATIVE | SYNC | PUBLIC | PROT | PRIVATE | SEP | ID | INT | FLOAT | WHITESPACE | STRING | CHAR | COMMENT | LINE_COMMENT );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa20_eot,	    /* EOT table			    */
	    dfa20_eof,	    /* EOF table			    */
	    dfa20_min,	    /* Minimum tokens for each state    */
	    dfa20_max,	    /* Maximum tokens for each state    */
	    dfa20_accept,	/* Accept table			    */
	    dfa20_special,	/* Special transition states	    */
	    dfa20_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 20
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the lexer
 */

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

//   Comes from: 7:8: ( '(' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__116
 *
 * Looks to match the characters the constitute the token T__116
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__116(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__116;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:7:8: ( '(' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:7:10: '('
    {
        MATCHC('(');
        if  (HASEXCEPTION())
        {
            goto ruleT__116Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__116Ex; /* Prevent compiler warnings */
    ruleT__116Ex: ;

}
// $ANTLR end T__116

//   Comes from: 8:8: ( ')' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__117
 *
 * Looks to match the characters the constitute the token T__117
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__117(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__117;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:8:8: ( ')' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:8:10: ')'
    {
        MATCHC(')');
        if  (HASEXCEPTION())
        {
            goto ruleT__117Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__117Ex; /* Prevent compiler warnings */
    ruleT__117Ex: ;

}
// $ANTLR end T__117

//   Comes from: 9:8: ( '+=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__118
 *
 * Looks to match the characters the constitute the token T__118
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__118(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__118;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:9:8: ( '+=' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:9:10: '+='
    {
        MATCHS(lit_1);
        if  (HASEXCEPTION())
        {
            goto ruleT__118Ex;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__118Ex; /* Prevent compiler warnings */
    ruleT__118Ex: ;

}
// $ANTLR end T__118

//   Comes from: 10:8: ( ',' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__119
 *
 * Looks to match the characters the constitute the token T__119
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__119(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__119;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:10:8: ( ',' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:10:10: ','
    {
        MATCHC(',');
        if  (HASEXCEPTION())
        {
            goto ruleT__119Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__119Ex; /* Prevent compiler warnings */
    ruleT__119Ex: ;

}
// $ANTLR end T__119

//   Comes from: 11:8: ( '-=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__120
 *
 * Looks to match the characters the constitute the token T__120
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__120(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__120;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:11:8: ( '-=' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:11:10: '-='
    {
        MATCHS(lit_2);
        if  (HASEXCEPTION())
        {
            goto ruleT__120Ex;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__120Ex; /* Prevent compiler warnings */
    ruleT__120Ex: ;

}
// $ANTLR end T__120

//   Comes from: 12:8: ( '.' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__121
 *
 * Looks to match the characters the constitute the token T__121
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__121(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__121;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:12:8: ( '.' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:12:10: '.'
    {
        MATCHC('.');
        if  (HASEXCEPTION())
        {
            goto ruleT__121Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__121Ex; /* Prevent compiler warnings */
    ruleT__121Ex: ;

}
// $ANTLR end T__121

//   Comes from: 13:8: ( ':' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__122
 *
 * Looks to match the characters the constitute the token T__122
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__122(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__122;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:13:8: ( ':' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:13:10: ':'
    {
        MATCHC(':');
        if  (HASEXCEPTION())
        {
            goto ruleT__122Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__122Ex; /* Prevent compiler warnings */
    ruleT__122Ex: ;

}
// $ANTLR end T__122

//   Comes from: 14:8: ( '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__123
 *
 * Looks to match the characters the constitute the token T__123
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__123(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__123;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:14:8: ( '=' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:14:10: '='
    {
        MATCHC('=');
        if  (HASEXCEPTION())
        {
            goto ruleT__123Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__123Ex; /* Prevent compiler warnings */
    ruleT__123Ex: ;

}
// $ANTLR end T__123

//   Comes from: 15:8: ( '@' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__124
 *
 * Looks to match the characters the constitute the token T__124
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__124(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__124;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:15:8: ( '@' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:15:10: '@'
    {
        MATCHC('@');
        if  (HASEXCEPTION())
        {
            goto ruleT__124Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__124Ex; /* Prevent compiler warnings */
    ruleT__124Ex: ;

}
// $ANTLR end T__124

//   Comes from: 16:8: ( '[' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__125
 *
 * Looks to match the characters the constitute the token T__125
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__125(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__125;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:16:8: ( '[' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:16:10: '['
    {
        MATCHC('[');
        if  (HASEXCEPTION())
        {
            goto ruleT__125Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__125Ex; /* Prevent compiler warnings */
    ruleT__125Ex: ;

}
// $ANTLR end T__125

//   Comes from: 17:8: ( ']' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__126
 *
 * Looks to match the characters the constitute the token T__126
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__126(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__126;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:17:8: ( ']' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:17:10: ']'
    {
        MATCHC(']');
        if  (HASEXCEPTION())
        {
            goto ruleT__126Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__126Ex; /* Prevent compiler warnings */
    ruleT__126Ex: ;

}
// $ANTLR end T__126

//   Comes from: 18:8: ( '{' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__127
 *
 * Looks to match the characters the constitute the token T__127
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__127(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__127;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:18:8: ( '{' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:18:10: '{'
    {
        MATCHC('{');
        if  (HASEXCEPTION())
        {
            goto ruleT__127Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__127Ex; /* Prevent compiler warnings */
    ruleT__127Ex: ;

}
// $ANTLR end T__127

//   Comes from: 19:8: ( '}' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T__128
 *
 * Looks to match the characters the constitute the token T__128
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT__128(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T__128;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:19:8: ( '}' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:19:10: '}'
    {
        MATCHC('}');
        if  (HASEXCEPTION())
        {
            goto ruleT__128Ex;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT__128Ex; /* Prevent compiler warnings */
    ruleT__128Ex: ;

}
// $ANTLR end T__128

//   Comes from: 404:10: ( 'package' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_PACKAGE
 *
 * Looks to match the characters the constitute the token T_PACKAGE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_PACKAGE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_PACKAGE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:404:10: ( 'package' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:404:12: 'package'
    {
        MATCHS(lit_3);
        if  (HASEXCEPTION())
        {
            goto ruleT_PACKAGEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_PACKAGEEx; /* Prevent compiler warnings */
    ruleT_PACKAGEEx: ;

}
// $ANTLR end T_PACKAGE

//   Comes from: 405:5: ( 'use' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start USE
 *
 * Looks to match the characters the constitute the token USE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUSE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = USE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:405:5: ( 'use' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:405:7: 'use'
    {
        MATCHS(lit_4);
        if  (HASEXCEPTION())
        {
            goto ruleUSEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUSEEx; /* Prevent compiler warnings */
    ruleUSEEx: ;

}
// $ANTLR end USE

//   Comes from: 406:7: ( 'class' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CLASS
 *
 * Looks to match the characters the constitute the token CLASS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCLASS(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CLASS;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:406:7: ( 'class' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:406:9: 'class'
    {
        MATCHS(lit_5);
        if  (HASEXCEPTION())
        {
            goto ruleCLASSEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCLASSEx; /* Prevent compiler warnings */
    ruleCLASSEx: ;

}
// $ANTLR end CLASS

//   Comes from: 407:9: ( 'interface' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INTRFACE
 *
 * Looks to match the characters the constitute the token INTRFACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINTRFACE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INTRFACE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:407:9: ( 'interface' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:407:11: 'interface'
    {
        MATCHS(lit_6);
        if  (HASEXCEPTION())
        {
            goto ruleINTRFACEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINTRFACEEx; /* Prevent compiler warnings */
    ruleINTRFACEEx: ;

}
// $ANTLR end INTRFACE

//   Comes from: 408:7: ( 'super' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SUPER
 *
 * Looks to match the characters the constitute the token SUPER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSUPER(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SUPER;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:408:7: ( 'super' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:408:9: 'super'
    {
        MATCHS(lit_7);
        if  (HASEXCEPTION())
        {
            goto ruleSUPEREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSUPEREx; /* Prevent compiler warnings */
    ruleSUPEREx: ;

}
// $ANTLR end SUPER

//   Comes from: 409:6: ( 'this' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THIS
 *
 * Looks to match the characters the constitute the token THIS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHIS(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = THIS;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:409:6: ( 'this' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:409:8: 'this'
    {
        MATCHS(lit_8);
        if  (HASEXCEPTION())
        {
            goto ruleTHISEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTHISEx; /* Prevent compiler warnings */
    ruleTHISEx: ;

}
// $ANTLR end THIS

//   Comes from: 410:9: ( 'extends' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXTENDS
 *
 * Looks to match the characters the constitute the token EXTENDS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXTENDS(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EXTENDS;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:410:9: ( 'extends' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:410:11: 'extends'
    {
        MATCHS(lit_9);
        if  (HASEXCEPTION())
        {
            goto ruleEXTENDSEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEXTENDSEx; /* Prevent compiler warnings */
    ruleEXTENDSEx: ;

}
// $ANTLR end EXTENDS

//   Comes from: 411:6: ( 'implements' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IMPL
 *
 * Looks to match the characters the constitute the token IMPL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIMPL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IMPL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:411:6: ( 'implements' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:411:8: 'implements'
    {
        MATCHS(lit_10);
        if  (HASEXCEPTION())
        {
            goto ruleIMPLEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIMPLEx; /* Prevent compiler warnings */
    ruleIMPLEx: ;

}
// $ANTLR end IMPL

//   Comes from: 412:5: ( 'new' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NEW
 *
 * Looks to match the characters the constitute the token NEW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNEW(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NEW;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:412:5: ( 'new' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:412:7: 'new'
    {
        MATCHS(lit_11);
        if  (HASEXCEPTION())
        {
            goto ruleNEWEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNEWEx; /* Prevent compiler warnings */
    ruleNEWEx: ;

}
// $ANTLR end NEW

//   Comes from: 413:9: ( 'instanceof' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INST_OF
 *
 * Looks to match the characters the constitute the token INST_OF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINST_OF(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INST_OF;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:413:9: ( 'instanceof' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:413:11: 'instanceof'
    {
        MATCHS(lit_12);
        if  (HASEXCEPTION())
        {
            goto ruleINST_OFEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINST_OFEx; /* Prevent compiler warnings */
    ruleINST_OFEx: ;

}
// $ANTLR end INST_OF

//   Comes from: 414:9: ( 'assert' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_ASSERT
 *
 * Looks to match the characters the constitute the token T_ASSERT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_ASSERT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_ASSERT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:414:9: ( 'assert' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:414:11: 'assert'
    {
        MATCHS(lit_13);
        if  (HASEXCEPTION())
        {
            goto ruleT_ASSERTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_ASSERTEx; /* Prevent compiler warnings */
    ruleT_ASSERTEx: ;

}
// $ANTLR end T_ASSERT

//   Comes from: 415:9: ( 'property' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROPERTY
 *
 * Looks to match the characters the constitute the token PROPERTY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPROPERTY(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PROPERTY;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:415:9: ( 'property' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:415:11: 'property'
    {
        MATCHS(lit_14);
        if  (HASEXCEPTION())
        {
            goto rulePROPERTYEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePROPERTYEx; /* Prevent compiler warnings */
    rulePROPERTYEx: ;

}
// $ANTLR end PROPERTY

//   Comes from: 416:5: ( 'for' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOR
 *
 * Looks to match the characters the constitute the token FOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFOR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FOR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:416:5: ( 'for' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:416:7: 'for'
    {
        MATCHS(lit_15);
        if  (HASEXCEPTION())
        {
            goto ruleFOREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFOREx; /* Prevent compiler warnings */
    ruleFOREx: ;

}
// $ANTLR end FOR

//   Comes from: 417:9: ( 'foreach' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FOREACH
 *
 * Looks to match the characters the constitute the token FOREACH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFOREACH(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FOREACH;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:417:9: ( 'foreach' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:417:11: 'foreach'
    {
        MATCHS(lit_16);
        if  (HASEXCEPTION())
        {
            goto ruleFOREACHEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFOREACHEx; /* Prevent compiler warnings */
    ruleFOREACHEx: ;

}
// $ANTLR end FOREACH

//   Comes from: 418:7: ( 'while' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHILE
 *
 * Looks to match the characters the constitute the token WHILE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHILE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHILE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:418:7: ( 'while' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:418:9: 'while'
    {
        MATCHS(lit_17);
        if  (HASEXCEPTION())
        {
            goto ruleWHILEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWHILEEx; /* Prevent compiler warnings */
    ruleWHILEEx: ;

}
// $ANTLR end WHILE

//   Comes from: 419:4: ( 'do' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DO
 *
 * Looks to match the characters the constitute the token DO
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDO(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DO;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:419:4: ( 'do' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:419:6: 'do'
    {
        MATCHS(lit_18);
        if  (HASEXCEPTION())
        {
            goto ruleDOEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDOEx; /* Prevent compiler warnings */
    ruleDOEx: ;

}
// $ANTLR end DO

//   Comes from: 420:8: ( 'switch' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SWITCH
 *
 * Looks to match the characters the constitute the token SWITCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSWITCH(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SWITCH;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:420:8: ( 'switch' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:420:10: 'switch'
    {
        MATCHS(lit_19);
        if  (HASEXCEPTION())
        {
            goto ruleSWITCHEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSWITCHEx; /* Prevent compiler warnings */
    ruleSWITCHEx: ;

}
// $ANTLR end SWITCH

//   Comes from: 421:6: ( 'case' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CASE
 *
 * Looks to match the characters the constitute the token CASE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCASE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CASE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:421:6: ( 'case' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:421:8: 'case'
    {
        MATCHS(lit_20);
        if  (HASEXCEPTION())
        {
            goto ruleCASEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCASEEx; /* Prevent compiler warnings */
    ruleCASEEx: ;

}
// $ANTLR end CASE

//   Comes from: 422:9: ( 'default' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DEFAULT
 *
 * Looks to match the characters the constitute the token DEFAULT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDEFAULT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DEFAULT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:422:9: ( 'default' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:422:11: 'default'
    {
        MATCHS(lit_21);
        if  (HASEXCEPTION())
        {
            goto ruleDEFAULTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDEFAULTEx; /* Prevent compiler warnings */
    ruleDEFAULTEx: ;

}
// $ANTLR end DEFAULT

//   Comes from: 423:7: ( 'break' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BREAK
 *
 * Looks to match the characters the constitute the token BREAK
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBREAK(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BREAK;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:423:7: ( 'break' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:423:9: 'break'
    {
        MATCHS(lit_22);
        if  (HASEXCEPTION())
        {
            goto ruleBREAKEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBREAKEx; /* Prevent compiler warnings */
    ruleBREAKEx: ;

}
// $ANTLR end BREAK

//   Comes from: 424:9: ( 'continue' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CONTINUE
 *
 * Looks to match the characters the constitute the token CONTINUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCONTINUE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CONTINUE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:424:9: ( 'continue' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:424:11: 'continue'
    {
        MATCHS(lit_23);
        if  (HASEXCEPTION())
        {
            goto ruleCONTINUEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCONTINUEEx; /* Prevent compiler warnings */
    ruleCONTINUEEx: ;

}
// $ANTLR end CONTINUE

//   Comes from: 425:8: ( 'return' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start RETURN
 *
 * Looks to match the characters the constitute the token RETURN
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mRETURN(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = RETURN;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:425:8: ( 'return' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:425:10: 'return'
    {
        MATCHS(lit_24);
        if  (HASEXCEPTION())
        {
            goto ruleRETURNEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleRETURNEx; /* Prevent compiler warnings */
    ruleRETURNEx: ;

}
// $ANTLR end RETURN

//   Comes from: 426:4: ( 'if' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start IF
 *
 * Looks to match the characters the constitute the token IF
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mIF(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = IF;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:426:4: ( 'if' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:426:6: 'if'
    {
        MATCHS(lit_25);
        if  (HASEXCEPTION())
        {
            goto ruleIFEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIFEx; /* Prevent compiler warnings */
    ruleIFEx: ;

}
// $ANTLR end IF

//   Comes from: 427:6: ( 'else' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ELSE
 *
 * Looks to match the characters the constitute the token ELSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mELSE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ELSE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:427:6: ( 'else' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:427:8: 'else'
    {
        MATCHS(lit_26);
        if  (HASEXCEPTION())
        {
            goto ruleELSEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleELSEEx; /* Prevent compiler warnings */
    ruleELSEEx: ;

}
// $ANTLR end ELSE

//   Comes from: 428:5: ( 'try' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start TRY
 *
 * Looks to match the characters the constitute the token TRY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTRY(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = TRY;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:428:5: ( 'try' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:428:7: 'try'
    {
        MATCHS(lit_27);
        if  (HASEXCEPTION())
        {
            goto ruleTRYEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTRYEx; /* Prevent compiler warnings */
    ruleTRYEx: ;

}
// $ANTLR end TRY

//   Comes from: 429:7: ( 'catch' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CATCH
 *
 * Looks to match the characters the constitute the token CATCH
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCATCH(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CATCH;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:429:7: ( 'catch' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:429:9: 'catch'
    {
        MATCHS(lit_28);
        if  (HASEXCEPTION())
        {
            goto ruleCATCHEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCATCHEx; /* Prevent compiler warnings */
    ruleCATCHEx: ;

}
// $ANTLR end CATCH

//   Comes from: 430:9: ( 'finally' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FINALLY
 *
 * Looks to match the characters the constitute the token FINALLY
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFINALLY(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FINALLY;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:430:9: ( 'finally' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:430:11: 'finally'
    {
        MATCHS(lit_29);
        if  (HASEXCEPTION())
        {
            goto ruleFINALLYEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFINALLYEx; /* Prevent compiler warnings */
    ruleFINALLYEx: ;

}
// $ANTLR end FINALLY

//   Comes from: 431:7: ( 'throw' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start THROW
 *
 * Looks to match the characters the constitute the token THROW
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mTHROW(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = THROW;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:431:7: ( 'throw' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:431:9: 'throw'
    {
        MATCHS(lit_30);
        if  (HASEXCEPTION())
        {
            goto ruleTHROWEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleTHROWEx; /* Prevent compiler warnings */
    ruleTHROWEx: ;

}
// $ANTLR end THROW

//   Comes from: 433:9: ( 'nullptr' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LITnullptr
 *
 * Looks to match the characters the constitute the token LITnullptr
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLITNULL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LITnullptr;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:433:9: ( 'NULL' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:433:11: 'NULL'
    {
        MATCHS(lit_31);
        if  (HASEXCEPTION())
        {
            goto ruleLITNULLEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLITNULLEx; /* Prevent compiler warnings */
    ruleLITNULLEx: ;

}
// $ANTLR end LITNULL

//   Comes from: 434:9: ( 'true' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LITTRUE
 *
 * Looks to match the characters the constitute the token LITTRUE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLITTRUE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LITTRUE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:434:9: ( 'true' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:434:11: 'true'
    {
        MATCHS(lit_32);
        if  (HASEXCEPTION())
        {
            goto ruleLITTRUEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLITTRUEEx; /* Prevent compiler warnings */
    ruleLITTRUEEx: ;

}
// $ANTLR end LITTRUE

//   Comes from: 435:9: ( 'false' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LITFALSE
 *
 * Looks to match the characters the constitute the token LITFALSE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLITFALSE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LITFALSE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:435:9: ( 'false' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:435:11: 'false'
    {
        MATCHS(lit_33);
        if  (HASEXCEPTION())
        {
            goto ruleLITFALSEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLITFALSEEx; /* Prevent compiler warnings */
    ruleLITFALSEEx: ;

}
// $ANTLR end LITFALSE

//   Comes from: 437:5: ( '&&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start AND
 *
 * Looks to match the characters the constitute the token AND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mAND(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = AND;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:437:5: ( '&&' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:437:7: '&&'
    {
        MATCHS(lit_34);
        if  (HASEXCEPTION())
        {
            goto ruleANDEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleANDEx; /* Prevent compiler warnings */
    ruleANDEx: ;

}
// $ANTLR end AND

//   Comes from: 438:4: ( '||' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OR
 *
 * Looks to match the characters the constitute the token OR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = OR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:438:4: ( '||' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:438:6: '||'
    {
        MATCHS(lit_35);
        if  (HASEXCEPTION())
        {
            goto ruleOREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleOREx; /* Prevent compiler warnings */
    ruleOREx: ;

}
// $ANTLR end OR

//   Comes from: 439:5: ( '*' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MUL
 *
 * Looks to match the characters the constitute the token MUL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMUL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MUL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:439:5: ( '*' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:439:7: '*'
    {
        MATCHC('*');
        if  (HASEXCEPTION())
        {
            goto ruleMULEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMULEx; /* Prevent compiler warnings */
    ruleMULEx: ;

}
// $ANTLR end MUL

//   Comes from: 440:5: ( '/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DIV
 *
 * Looks to match the characters the constitute the token DIV
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDIV(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DIV;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:440:5: ( '/' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:440:7: '/'
    {
        MATCHC('/');
        if  (HASEXCEPTION())
        {
            goto ruleDIVEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDIVEx; /* Prevent compiler warnings */
    ruleDIVEx: ;

}
// $ANTLR end DIV

//   Comes from: 441:5: ( '%' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start REM
 *
 * Looks to match the characters the constitute the token REM
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mREM(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = REM;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:441:5: ( '%' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:441:7: '%'
    {
        MATCHC('%');
        if  (HASEXCEPTION())
        {
            goto ruleREMEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleREMEx; /* Prevent compiler warnings */
    ruleREMEx: ;

}
// $ANTLR end REM

//   Comes from: 442:6: ( '+' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PLUS
 *
 * Looks to match the characters the constitute the token PLUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPLUS(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PLUS;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:442:6: ( '+' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:442:8: '+'
    {
        MATCHC('+');
        if  (HASEXCEPTION())
        {
            goto rulePLUSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePLUSEx; /* Prevent compiler warnings */
    rulePLUSEx: ;

}
// $ANTLR end PLUS

//   Comes from: 443:7: ( '-' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start MINUS
 *
 * Looks to match the characters the constitute the token MINUS
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mMINUS(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = MINUS;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:443:7: ( '-' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:443:9: '-'
    {
        MATCHC('-');
        if  (HASEXCEPTION())
        {
            goto ruleMINUSEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleMINUSEx; /* Prevent compiler warnings */
    ruleMINUSEx: ;

}
// $ANTLR end MINUS

//   Comes from: 444:9: ( '~' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITCOMPL
 *
 * Looks to match the characters the constitute the token BITCOMPL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITCOMPL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITCOMPL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:444:9: ( '~' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:444:11: '~'
    {
        MATCHC('~');
        if  (HASEXCEPTION())
        {
            goto ruleBITCOMPLEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITCOMPLEx; /* Prevent compiler warnings */
    ruleBITCOMPLEx: ;

}
// $ANTLR end BITCOMPL

//   Comes from: 445:5: ( '!' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NOT
 *
 * Looks to match the characters the constitute the token NOT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNOT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NOT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:445:5: ( '!' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:445:7: '!'
    {
        MATCHC('!');
        if  (HASEXCEPTION())
        {
            goto ruleNOTEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNOTEx; /* Prevent compiler warnings */
    ruleNOTEx: ;

}
// $ANTLR end NOT

//   Comes from: 446:8: ( '&' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITAND
 *
 * Looks to match the characters the constitute the token BITAND
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITAND(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITAND;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:446:8: ( '&' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:446:10: '&'
    {
        MATCHC('&');
        if  (HASEXCEPTION())
        {
            goto ruleBITANDEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITANDEx; /* Prevent compiler warnings */
    ruleBITANDEx: ;

}
// $ANTLR end BITAND

//   Comes from: 447:7: ( '|' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITOR
 *
 * Looks to match the characters the constitute the token BITOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITOR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITOR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:447:7: ( '|' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:447:9: '|'
    {
        MATCHC('|');
        if  (HASEXCEPTION())
        {
            goto ruleBITOREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITOREx; /* Prevent compiler warnings */
    ruleBITOREx: ;

}
// $ANTLR end BITOR

//   Comes from: 448:8: ( '^' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start BITXOR
 *
 * Looks to match the characters the constitute the token BITXOR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mBITXOR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = BITXOR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:448:8: ( '^' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:448:10: '^'
    {
        MATCHC('^');
        if  (HASEXCEPTION())
        {
            goto ruleBITXOREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleBITXOREx; /* Prevent compiler warnings */
    ruleBITXOREx: ;

}
// $ANTLR end BITXOR

//   Comes from: 449:6: ( '++' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INCR
 *
 * Looks to match the characters the constitute the token INCR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINCR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INCR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:449:6: ( '++' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:449:8: '++'
    {
        MATCHS(lit_36);
        if  (HASEXCEPTION())
        {
            goto ruleINCREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINCREx; /* Prevent compiler warnings */
    ruleINCREx: ;

}
// $ANTLR end INCR

//   Comes from: 450:6: ( '--' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start DECR
 *
 * Looks to match the characters the constitute the token DECR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mDECR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = DECR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:450:6: ( '--' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:450:8: '--'
    {
        MATCHS(lit_37);
        if  (HASEXCEPTION())
        {
            goto ruleDECREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleDECREx; /* Prevent compiler warnings */
    ruleDECREx: ;

}
// $ANTLR end DECR

//   Comes from: 451:7: ( '==' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EQUAL
 *
 * Looks to match the characters the constitute the token EQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEQUAL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = EQUAL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:451:7: ( '==' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:451:9: '=='
    {
        MATCHS(lit_38);
        if  (HASEXCEPTION())
        {
            goto ruleEQUALEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleEQUALEx; /* Prevent compiler warnings */
    ruleEQUALEx: ;

}
// $ANTLR end EQUAL

//   Comes from: 452:9: ( '!=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNEQUAL
 *
 * Looks to match the characters the constitute the token UNEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNEQUAL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = UNEQUAL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:452:9: ( '!=' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:452:11: '!='
    {
        MATCHS(lit_39);
        if  (HASEXCEPTION())
        {
            goto ruleUNEQUALEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleUNEQUALEx; /* Prevent compiler warnings */
    ruleUNEQUALEx: ;

}
// $ANTLR end UNEQUAL

//   Comes from: 453:8: ( '<' '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEQUAL
 *
 * Looks to match the characters the constitute the token SEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEQUAL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SEQUAL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:453:8: ( '<' '=' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:453:10: '<' '='
    {
        MATCHC('<');
        if  (HASEXCEPTION())
        {
            goto ruleSEQUALEx;
        }


        MATCHC('=');
        if  (HASEXCEPTION())
        {
            goto ruleSEQUALEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSEQUALEx; /* Prevent compiler warnings */
    ruleSEQUALEx: ;

}
// $ANTLR end SEQUAL

//   Comes from: 454:9: ( '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SMALLER
 *
 * Looks to match the characters the constitute the token SMALLER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSMALLER(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SMALLER;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:454:9: ( '<' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:454:11: '<'
    {
        MATCHC('<');
        if  (HASEXCEPTION())
        {
            goto ruleSMALLEREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSMALLEREx; /* Prevent compiler warnings */
    ruleSMALLEREx: ;

}
// $ANTLR end SMALLER

//   Comes from: 455:9: ( '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GREATER
 *
 * Looks to match the characters the constitute the token GREATER
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGREATER(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GREATER;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:455:9: ( '>' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:455:11: '>'
    {
        MATCHC('>');
        if  (HASEXCEPTION())
        {
            goto ruleGREATEREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGREATEREx; /* Prevent compiler warnings */
    ruleGREATEREx: ;

}
// $ANTLR end GREATER

//   Comes from: 456:8: ( '>' '=' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start GEQUAL
 *
 * Looks to match the characters the constitute the token GEQUAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mGEQUAL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = GEQUAL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:456:8: ( '>' '=' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:456:10: '>' '='
    {
        MATCHC('>');
        if  (HASEXCEPTION())
        {
            goto ruleGEQUALEx;
        }


        MATCHC('=');
        if  (HASEXCEPTION())
        {
            goto ruleGEQUALEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleGEQUALEx; /* Prevent compiler warnings */
    ruleGEQUALEx: ;

}
// $ANTLR end GEQUAL

//   Comes from: 457:8: ( '<' '<' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHIFTL
 *
 * Looks to match the characters the constitute the token SHIFTL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHIFTL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHIFTL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:457:8: ( '<' '<' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:457:10: '<' '<'
    {
        MATCHC('<');
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTLEx;
        }


        MATCHC('<');
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTLEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHIFTLEx; /* Prevent compiler warnings */
    ruleSHIFTLEx: ;

}
// $ANTLR end SHIFTL

//   Comes from: 458:8: ( '>' '>' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SHIFTR
 *
 * Looks to match the characters the constitute the token SHIFTR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSHIFTR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SHIFTR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:458:8: ( '>' '>' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:458:10: '>' '>'
    {
        MATCHC('>');
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTREx;
        }


        MATCHC('>');
        if  (HASEXCEPTION())
        {
            goto ruleSHIFTREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSHIFTREx; /* Prevent compiler warnings */
    ruleSHIFTREx: ;

}
// $ANTLR end SHIFTR

//   Comes from: 460:8: ( 'char' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_CHAR
 *
 * Looks to match the characters the constitute the token T_CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_CHAR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_CHAR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:460:8: ( 'char' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:460:10: 'char'
    {
        MATCHS(lit_40);
        if  (HASEXCEPTION())
        {
            goto ruleT_CHAREx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_CHAREx; /* Prevent compiler warnings */
    ruleT_CHAREx: ;

}
// $ANTLR end T_CHAR

//   Comes from: 461:7: ( 'int' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_INT
 *
 * Looks to match the characters the constitute the token T_INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_INT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_INT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:461:7: ( 'int' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:461:9: 'int'
    {
        MATCHS(lit_41);
        if  (HASEXCEPTION())
        {
            goto ruleT_INTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_INTEx; /* Prevent compiler warnings */
    ruleT_INTEx: ;

}
// $ANTLR end T_INT

//   Comes from: 462:8: ( 'real' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_REAL
 *
 * Looks to match the characters the constitute the token T_REAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_REAL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_REAL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:462:8: ( 'real' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:462:10: 'real'
    {
        MATCHS(lit_42);
        if  (HASEXCEPTION())
        {
            goto ruleT_REALEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_REALEx; /* Prevent compiler warnings */
    ruleT_REALEx: ;

}
// $ANTLR end T_REAL

//   Comes from: 463:9: ( 'string' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_STRING
 *
 * Looks to match the characters the constitute the token T_STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_STRING(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_STRING;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:463:9: ( 'string' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:463:11: 'string'
    {
        MATCHS(lit_43);
        if  (HASEXCEPTION())
        {
            goto ruleT_STRINGEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_STRINGEx; /* Prevent compiler warnings */
    ruleT_STRINGEx: ;

}
// $ANTLR end T_STRING

//   Comes from: 464:8: ( 'boolean' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_BOOL
 *
 * Looks to match the characters the constitute the token T_BOOL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_BOOL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_BOOL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:464:8: ( 'boolean' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:464:10: 'boolean'
    {
        MATCHS(lit_44);
        if  (HASEXCEPTION())
        {
            goto ruleT_BOOLEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_BOOLEx; /* Prevent compiler warnings */
    ruleT_BOOLEx: ;

}
// $ANTLR end T_BOOL

//   Comes from: 465:8: ( 'void' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start T_VOID
 *
 * Looks to match the characters the constitute the token T_VOID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mT_VOID(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = T_VOID;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:465:8: ( 'void' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:465:10: 'void'
    {
        MATCHS(lit_45);
        if  (HASEXCEPTION())
        {
            goto ruleT_VOIDEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleT_VOIDEx; /* Prevent compiler warnings */
    ruleT_VOIDEx: ;

}
// $ANTLR end T_VOID

//   Comes from: 467:8: ( 'static' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STATIC
 *
 * Looks to match the characters the constitute the token STATIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTATIC(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STATIC;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:467:8: ( 'static' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:467:10: 'static'
    {
        MATCHS(lit_46);
        if  (HASEXCEPTION())
        {
            goto ruleSTATICEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTATICEx; /* Prevent compiler warnings */
    ruleSTATICEx: ;

}
// $ANTLR end STATIC

//   Comes from: 468:7: ( 'final' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FINAL
 *
 * Looks to match the characters the constitute the token FINAL
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFINAL(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FINAL;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:468:7: ( 'final' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:468:9: 'final'
    {
        MATCHS(lit_47);
        if  (HASEXCEPTION())
        {
            goto ruleFINALEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFINALEx; /* Prevent compiler warnings */
    ruleFINALEx: ;

}
// $ANTLR end FINAL

//   Comes from: 469:9: ( 'abstract' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ABSTRACT
 *
 * Looks to match the characters the constitute the token ABSTRACT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mABSTRACT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ABSTRACT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:469:9: ( 'abstract' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:469:11: 'abstract'
    {
        MATCHS(lit_48);
        if  (HASEXCEPTION())
        {
            goto ruleABSTRACTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleABSTRACTEx; /* Prevent compiler warnings */
    ruleABSTRACTEx: ;

}
// $ANTLR end ABSTRACT

//   Comes from: 470:8: ( 'native' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start NATIVE
 *
 * Looks to match the characters the constitute the token NATIVE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mNATIVE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = NATIVE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:470:8: ( 'native' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:470:10: 'native'
    {
        MATCHS(lit_49);
        if  (HASEXCEPTION())
        {
            goto ruleNATIVEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleNATIVEEx; /* Prevent compiler warnings */
    ruleNATIVEEx: ;

}
// $ANTLR end NATIVE

//   Comes from: 471:6: ( 'synchronized' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SYNC
 *
 * Looks to match the characters the constitute the token SYNC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSYNC(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SYNC;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:471:6: ( 'synchronized' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:471:8: 'synchronized'
    {
        MATCHS(lit_50);
        if  (HASEXCEPTION())
        {
            goto ruleSYNCEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSYNCEx; /* Prevent compiler warnings */
    ruleSYNCEx: ;

}
// $ANTLR end SYNC

//   Comes from: 472:8: ( 'public' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PUBLIC
 *
 * Looks to match the characters the constitute the token PUBLIC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPUBLIC(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PUBLIC;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:472:8: ( 'public' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:472:10: 'public'
    {
        MATCHS(lit_51);
        if  (HASEXCEPTION())
        {
            goto rulePUBLICEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePUBLICEx; /* Prevent compiler warnings */
    rulePUBLICEx: ;

}
// $ANTLR end PUBLIC

//   Comes from: 473:6: ( 'protected' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PROT
 *
 * Looks to match the characters the constitute the token PROT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPROT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PROT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:473:6: ( 'protected' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:473:8: 'protected'
    {
        MATCHS(lit_52);
        if  (HASEXCEPTION())
        {
            goto rulePROTEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePROTEx; /* Prevent compiler warnings */
    rulePROTEx: ;

}
// $ANTLR end PROT

//   Comes from: 474:9: ( 'private' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start PRIVATE
 *
 * Looks to match the characters the constitute the token PRIVATE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mPRIVATE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = PRIVATE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:474:9: ( 'private' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:474:11: 'private'
    {
        MATCHS(lit_53);
        if  (HASEXCEPTION())
        {
            goto rulePRIVATEEx;
        }




    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto rulePRIVATEEx; /* Prevent compiler warnings */
    rulePRIVATEEx: ;

}
// $ANTLR end PRIVATE

//   Comes from: 476:5: ( ';' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start SEP
 *
 * Looks to match the characters the constitute the token SEP
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSEP(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = SEP;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:476:5: ( ';' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:476:7: ';'
    {
        MATCHC(';');
        if  (HASEXCEPTION())
        {
            goto ruleSEPEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSEPEx; /* Prevent compiler warnings */
    ruleSEPEx: ;

}
// $ANTLR end SEP

//   Comes from: 478:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ID
 *
 * Looks to match the characters the constitute the token ID
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mID(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = ID;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:478:5: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )* )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:478:7: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*
    {
        if ( ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleIDEx;
        }


        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:478:31: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' )*

        for (;;)
        {
            int alt1=2;
            switch ( LA(1) )
            {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '_':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
            case 'g':
            case 'h':
            case 'i':
            case 'j':
            case 'k':
            case 'l':
            case 'm':
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 'r':
            case 's':
            case 't':
            case 'u':
            case 'v':
            case 'w':
            case 'x':
            case 'y':
            case 'z':
            	{
            		alt1=1;
            	}
                break;

            }

            switch (alt1)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
        	    {
        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'Z')) || LA(1) == '_' || ((LA(1) >= 'a') && (LA(1) <= 'z')) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleIDEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop1;	/* break out of the loop */
        	    break;
            }
        }
        loop1: ; /* Jump out to here if this rule does not match */


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleIDEx; /* Prevent compiler warnings */
    ruleIDEx: ;

}
// $ANTLR end ID

//   Comes from: 481:5: ( ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start INT
 *
 * Looks to match the characters the constitute the token INT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mINT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = INT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:481:5: ( ( '0' .. '9' )+ )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:481:7: ( '0' .. '9' )+
    {
        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:481:7: ( '0' .. '9' )+
        {
            int cnt2=0;

            for (;;)
            {
                int alt2=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt2=1;
        		}
        	    break;

        	}

        	switch (alt2)
        	{
        	    case 1:
        	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleINTEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt2 >= 1 )
        		{
        		    goto loop2;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleINTEx;
        	}
        	cnt2++;
            }
            loop2: ;	/* Jump to here if this rule does not match */
        }

    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleINTEx; /* Prevent compiler warnings */
    ruleINTEx: ;

}
// $ANTLR end INT

//   Comes from: 485:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start FLOAT
 *
 * Looks to match the characters the constitute the token FLOAT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mFLOAT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = FLOAT;


    {
        //  F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:485:5: ( ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )? | '.' ( '0' .. '9' )+ ( EXPONENT )? | ( '0' .. '9' )+ EXPONENT )

        ANTLR3_UINT32 alt9;

        alt9=3;

        alt9 = cdfa9.predict(ctx, RECOGNIZER, ISTREAM, &cdfa9);
        if  (HASEXCEPTION())
        {
            goto ruleFLOATEx;
        }

        switch (alt9)
        {
    	case 1:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:485:9: ( '0' .. '9' )+ '.' ( '0' .. '9' )* ( EXPONENT )?
    	    {
    	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:485:9: ( '0' .. '9' )+
    	        {
    	            int cnt3=0;

    	            for (;;)
    	            {
    	                int alt3=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt3=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt3)
    	        	{
    	        	    case 1:
    	        	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleFLOATEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt3 >= 1 )
    	        		{
    	        		    goto loop3;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATEx;
    	        	}
    	        	cnt3++;
    	            }
    	            loop3: ;	/* Jump to here if this rule does not match */
    	        }

    	        MATCHC('.');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATEx;
    	        }


    	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:485:25: ( '0' .. '9' )*

    	        for (;;)
    	        {
    	            int alt4=2;
    	            switch ( LA(1) )
    	            {
    	            case '0':
    	            case '1':
    	            case '2':
    	            case '3':
    	            case '4':
    	            case '5':
    	            case '6':
    	            case '7':
    	            case '8':
    	            case '9':
    	            	{
    	            		alt4=1;
    	            	}
    	                break;

    	            }

    	            switch (alt4)
    	            {
    	        	case 1:
    	        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
    	        	    {
    	        	        if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	        {
    	        	            CONSUME();
    	        	        }
    	        	        else
    	        	        {
    	        	            CONSTRUCTEX();
    	        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	            LRECOVER();
    	        	            goto ruleFLOATEx;
    	        	        }


    	        	    }
    	        	    break;

    	        	default:
    	        	    goto loop4;	/* break out of the loop */
    	        	    break;
    	            }
    	        }
    	        loop4: ; /* Jump out to here if this rule does not match */


    	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:485:37: ( EXPONENT )?
    	        {
    	            int alt5=2;
    	            switch ( LA(1) )
    	            {
    	                case 'E':
    	                case 'e':
    	                	{
    	                		alt5=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt5)
    	            {
    	        	case 1:
    	        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:485:37: EXPONENT
    	        	    {
    	        	        /* 485:37: EXPONENT */
    	        	        mEXPONENT(ctx );
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATEx;
    	        	        }



    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 2:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:486:9: '.' ( '0' .. '9' )+ ( EXPONENT )?
    	    {
    	        MATCHC('.');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATEx;
    	        }


    	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:486:13: ( '0' .. '9' )+
    	        {
    	            int cnt6=0;

    	            for (;;)
    	            {
    	                int alt6=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt6=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt6)
    	        	{
    	        	    case 1:
    	        	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleFLOATEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt6 >= 1 )
    	        		{
    	        		    goto loop6;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATEx;
    	        	}
    	        	cnt6++;
    	            }
    	            loop6: ;	/* Jump to here if this rule does not match */
    	        }

    	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:486:25: ( EXPONENT )?
    	        {
    	            int alt7=2;
    	            switch ( LA(1) )
    	            {
    	                case 'E':
    	                case 'e':
    	                	{
    	                		alt7=1;
    	                	}
    	                    break;
    	            }

    	            switch (alt7)
    	            {
    	        	case 1:
    	        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:486:25: EXPONENT
    	        	    {
    	        	        /* 486:25: EXPONENT */
    	        	        mEXPONENT(ctx );
    	        	        if  (HASEXCEPTION())
    	        	        {
    	        	            goto ruleFLOATEx;
    	        	        }



    	        	    }
    	        	    break;

    	            }
    	        }

    	    }
    	    break;
    	case 3:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:487:9: ( '0' .. '9' )+ EXPONENT
    	    {
    	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:487:9: ( '0' .. '9' )+
    	        {
    	            int cnt8=0;

    	            for (;;)
    	            {
    	                int alt8=2;
    	        	switch ( LA(1) )
    	        	{
    	        	case '0':
    	        	case '1':
    	        	case '2':
    	        	case '3':
    	        	case '4':
    	        	case '5':
    	        	case '6':
    	        	case '7':
    	        	case '8':
    	        	case '9':
    	        		{
    	        			alt8=1;
    	        		}
    	        	    break;

    	        	}

    	        	switch (alt8)
    	        	{
    	        	    case 1:
    	        	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
    	        	        {
    	        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
    	        	            {
    	        	                CONSUME();
    	        	            }
    	        	            else
    	        	            {
    	        	                CONSTRUCTEX();
    	        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	        	                LRECOVER();
    	        	                goto ruleFLOATEx;
    	        	            }


    	        	        }
    	        	        break;

    	        	    default:

    	        		if ( cnt8 >= 1 )
    	        		{
    	        		    goto loop8;
    	        		}
    	        		/* mismatchedSetEx()
    	        		 */
    	        		CONSTRUCTEX();
    	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
    	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


    	        		goto ruleFLOATEx;
    	        	}
    	        	cnt8++;
    	            }
    	            loop8: ;	/* Jump to here if this rule does not match */
    	        }

    	        /* 487:9: ( '0' .. '9' )+ EXPONENT */
    	        mEXPONENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleFLOATEx;
    	        }



    	    }
    	    break;

        }
    }
	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleFLOATEx; /* Prevent compiler warnings */
    ruleFLOATEx: ;

}
// $ANTLR end FLOAT

//   Comes from: 491:5: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start WHITESPACE
 *
 * Looks to match the characters the constitute the token WHITESPACE
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mWHITESPACE(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = WHITESPACE;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:491:5: ( ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+ )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:491:7: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
    {
        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:491:7: ( '\\t' | ' ' | '\\r' | '\\n' | '\\u000C' )+
        {
            int cnt10=0;

            for (;;)
            {
                int alt10=2;
        	switch ( LA(1) )
        	{
        	case '\t':
        	case '\n':
        	case '\f':
        	case '\r':
        	case ' ':
        		{
        			alt10=1;
        		}
        	    break;

        	}

        	switch (alt10)
        	{
        	    case 1:
        	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
        	        {
        	            if ( ((LA(1) >= '\t') && (LA(1) <= '\n')) || ((LA(1) >= '\f') && (LA(1) <= '\r')) || LA(1) == ' ' )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleWHITESPACEEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt10 >= 1 )
        		{
        		    goto loop10;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleWHITESPACEEx;
        	}
        	cnt10++;
            }
            loop10: ;	/* Jump to here if this rule does not match */
        }

        {
             LEXSTATE->channel = HIDDEN; 
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleWHITESPACEEx; /* Prevent compiler warnings */
    ruleWHITESPACEEx: ;

}
// $ANTLR end WHITESPACE

//   Comes from: 495:5: ( '\"' ( ESC_SEQ |~ ( '\\\\' | '\"' ) )* '\"' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start STRING
 *
 * Looks to match the characters the constitute the token STRING
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mSTRING(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = STRING;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:495:5: ( '\"' ( ESC_SEQ |~ ( '\\\\' | '\"' ) )* '\"' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:495:8: '\"' ( ESC_SEQ |~ ( '\\\\' | '\"' ) )* '\"'
    {
        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }


        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:495:12: ( ESC_SEQ |~ ( '\\\\' | '\"' ) )*

        for (;;)
        {
            int alt11=3;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA11_0 = LA(1);
                if ( (LA11_0 == '\\'))
                {
                    alt11=1;
                }
                else if ( (((LA11_0 >= 0x0000) && (LA11_0 <= '!')) || ((LA11_0 >= '#') && (LA11_0 <= '[')) || ((LA11_0 >= ']') && (LA11_0 <= 0xFFFF))))
                {
                    alt11=2;
                }

            }
            switch (alt11)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:495:14: ESC_SEQ
        	    {
        	        /* 495:14: ESC_SEQ */
        	        mESC_SEQ(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleSTRINGEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:495:24: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleSTRINGEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop11;	/* break out of the loop */
        	    break;
            }
        }
        loop11: ; /* Jump out to here if this rule does not match */


        MATCHC('"');
        if  (HASEXCEPTION())
        {
            goto ruleSTRINGEx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleSTRINGEx; /* Prevent compiler warnings */
    ruleSTRINGEx: ;

}
// $ANTLR end STRING

//   Comes from: 498:5: ( '\\'' ( ESC_SEQ |~ ( '\\\\' | '\"' ) ) '\\'' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start CHAR
 *
 * Looks to match the characters the constitute the token CHAR
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCHAR(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = CHAR;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:498:5: ( '\\'' ( ESC_SEQ |~ ( '\\\\' | '\"' ) ) '\\'' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:498:8: '\\'' ( ESC_SEQ |~ ( '\\\\' | '\"' ) ) '\\''
    {
        MATCHC('\'');
        if  (HASEXCEPTION())
        {
            goto ruleCHAREx;
        }


        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:498:13: ( ESC_SEQ |~ ( '\\\\' | '\"' ) )
        {
            int alt12=2;
            {
                int LA12_0 = LA(1);
                if ( (LA12_0 == '\\'))
                {
                    alt12=1;
                }
                else if ( (((LA12_0 >= 0x0000) && (LA12_0 <= '!')) || ((LA12_0 >= '#') && (LA12_0 <= '[')) || ((LA12_0 >= ']') && (LA12_0 <= 0xFFFF))))
                {
                    alt12=2;
                }
                else
                {

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 12;
                    EXCEPTION->state        = 0;


                    goto ruleCHAREx;

                }
            }
            switch (alt12)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:498:14: ESC_SEQ
        	    {
        	        /* 498:14: ESC_SEQ */
        	        mESC_SEQ(ctx );
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCHAREx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:498:24: ~ ( '\\\\' | '\"' )
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '!')) || ((LA(1) >= '#') && (LA(1) <= '[')) || ((LA(1) >= ']') && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleCHAREx;
        	        }


        	    }
        	    break;

            }
        }

        MATCHC('\'');
        if  (HASEXCEPTION())
        {
            goto ruleCHAREx;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCHAREx; /* Prevent compiler warnings */
    ruleCHAREx: ;

}
// $ANTLR end CHAR

//   Comes from: 502:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start COMMENT
 *
 * Looks to match the characters the constitute the token COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mCOMMENT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = COMMENT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:502:5: ( '/*' ( options {greedy=false; } : . )* '*/' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:502:9: '/*' ( options {greedy=false; } : . )* '*/'
    {
        MATCHS(lit_54);
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }




        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:502:14: ( options {greedy=false; } : . )*

        for (;;)
        {
            int alt13=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA13_0 = LA(1);
                if ( (LA13_0 == '*'))
                {
                    {
                       /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                        */
                        int LA13_1 = LA(2);
                        if ( (LA13_1 == '/'))
                        {
                            alt13=2;
                        }
                        else if ( (((LA13_1 >= 0x0000) && (LA13_1 <= '.')) || ((LA13_1 >= '0') && (LA13_1 <= 0xFFFF))))
                        {
                            alt13=1;
                        }

                    }
                }
                else if ( (((LA13_0 >= 0x0000) && (LA13_0 <= ')')) || ((LA13_0 >= '+') && (LA13_0 <= 0xFFFF))))
                {
                    alt13=1;
                }

            }
            switch (alt13)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:502:42: .
        	    {
        	        MATCHANY();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleCOMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop13;	/* break out of the loop */
        	    break;
            }
        }
        loop13: ; /* Jump out to here if this rule does not match */


        MATCHS(lit_55);
        if  (HASEXCEPTION())
        {
            goto ruleCOMMENTEx;
        }




        {
            LEXSTATE->channel=HIDDEN;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleCOMMENTEx; /* Prevent compiler warnings */
    ruleCOMMENTEx: ;

}
// $ANTLR end COMMENT

//   Comes from: 506:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start LINE_COMMENT
 *
 * Looks to match the characters the constitute the token LINE_COMMENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mLINE_COMMENT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;

    _type	    = LINE_COMMENT;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:506:5: ( '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n' )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:506:7: '//' (~ ( '\\n' | '\\r' ) )* ( '\\r' )? '\\n'
    {
        MATCHS(lit_56);
        if  (HASEXCEPTION())
        {
            goto ruleLINE_COMMENTEx;
        }




        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:506:12: (~ ( '\\n' | '\\r' ) )*

        for (;;)
        {
            int alt14=2;
            {
               /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                */
                int LA14_0 = LA(1);
                if ( (((LA14_0 >= 0x0000) && (LA14_0 <= '\t')) || ((LA14_0 >= 0x000B) && (LA14_0 <= '\f')) || ((LA14_0 >= 0x000E) && (LA14_0 <= 0xFFFF))))
                {
                    alt14=1;
                }

            }
            switch (alt14)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
        	    {
        	        if ( ((LA(1) >= 0x0000) && (LA(1) <= '\t')) || ((LA(1) >= 0x000B) && (LA(1) <= '\f')) || ((LA(1) >= 0x000E) && (LA(1) <= 0xFFFF)) )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop14;	/* break out of the loop */
        	    break;
            }
        }
        loop14: ; /* Jump out to here if this rule does not match */


        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:506:26: ( '\\r' )?
        {
            int alt15=2;
            switch ( LA(1) )
            {
                case '\r':
                	{
                		alt15=1;
                	}
                    break;
            }

            switch (alt15)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:506:26: '\\r'
        	    {
        	        MATCHC('\r');
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleLINE_COMMENTEx;
        	        }


        	    }
        	    break;

            }
        }

        MATCHC('\n');
        if  (HASEXCEPTION())
        {
            goto ruleLINE_COMMENTEx;
        }


        {
            LEXSTATE->channel=HIDDEN;
        }


    }

	LEXSTATE->type = _type;
    // This is where rules clean up and exit
    //
    goto ruleLINE_COMMENTEx; /* Prevent compiler warnings */
    ruleLINE_COMMENTEx: ;

}
// $ANTLR end LINE_COMMENT

//   Comes from: 511:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start EXPONENT
 *
 * Looks to match the characters the constitute the token EXPONENT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mEXPONENT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:511:10: ( ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+ )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:511:12: ( 'e' | 'E' ) ( '+' | '-' )? ( '0' .. '9' )+
    {
        if ( LA(1) == 'E' || LA(1) == 'e' )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleEXPONENTEx;
        }


        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:511:22: ( '+' | '-' )?
        {
            int alt16=2;
            switch ( LA(1) )
            {
                case '+':
                case '-':
                	{
                		alt16=1;
                	}
                    break;
            }

            switch (alt16)
            {
        	case 1:
        	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
        	    {
        	        if ( LA(1) == '+' || LA(1) == '-' )
        	        {
        	            CONSUME();
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            LRECOVER();
        	            goto ruleEXPONENTEx;
        	        }


        	    }
        	    break;

            }
        }

        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:511:33: ( '0' .. '9' )+
        {
            int cnt17=0;

            for (;;)
            {
                int alt17=2;
        	switch ( LA(1) )
        	{
        	case '0':
        	case '1':
        	case '2':
        	case '3':
        	case '4':
        	case '5':
        	case '6':
        	case '7':
        	case '8':
        	case '9':
        		{
        			alt17=1;
        		}
        	    break;

        	}

        	switch (alt17)
        	{
        	    case 1:
        	        // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
        	        {
        	            if ( ((LA(1) >= '0') && (LA(1) <= '9')) )
        	            {
        	                CONSUME();
        	            }
        	            else
        	            {
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	                LRECOVER();
        	                goto ruleEXPONENTEx;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt17 >= 1 )
        		{
        		    goto loop17;
        		}
        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto ruleEXPONENTEx;
        	}
        	cnt17++;
            }
            loop17: ;	/* Jump to here if this rule does not match */
        }

    }


    // This is where rules clean up and exit
    //
    goto ruleEXPONENTEx; /* Prevent compiler warnings */
    ruleEXPONENTEx: ;

}
// $ANTLR end EXPONENT

//   Comes from: 514:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start HEX_DIGIT
 *
 * Looks to match the characters the constitute the token HEX_DIGIT
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mHEX_DIGIT(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:514:11: ( ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' ) )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:
    {
        if ( ((LA(1) >= '0') && (LA(1) <= '9')) || ((LA(1) >= 'A') && (LA(1) <= 'F')) || ((LA(1) >= 'a') && (LA(1) <= 'f')) )
        {
            CONSUME();
        }
        else
        {
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

            LRECOVER();
            goto ruleHEX_DIGITEx;
        }


    }


    // This is where rules clean up and exit
    //
    goto ruleHEX_DIGITEx; /* Prevent compiler warnings */
    ruleHEX_DIGITEx: ;

}
// $ANTLR end HEX_DIGIT

//   Comes from: 518:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start ESC_SEQ
 *
 * Looks to match the characters the constitute the token ESC_SEQ
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mESC_SEQ(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;


    {
        //  F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:518:5: ( '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' ) | UNICODE_ESC | OCTAL_ESC )

        ANTLR3_UINT32 alt18;

        alt18=3;

        switch ( LA(1) )
        {
        case '\\':
        	{
        		switch ( LA(2) )
        		{
        		case '"':
        		case '\'':
        		case '\\':
        		case 'b':
        		case 'f':
        		case 'n':
        		case 'r':
        		case 't':
        			{
        				alt18=1;
        			}
        		    break;
        		case 'u':
        			{
        				alt18=2;
        			}
        		    break;
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				alt18=3;
        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 18;
        		    EXCEPTION->state        = 1;


        		    goto ruleESC_SEQEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 18;
            EXCEPTION->state        = 0;


            goto ruleESC_SEQEx;

        }

        switch (alt18)
        {
    	case 1:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:518:9: '\\\\' ( 'b' | 't' | 'n' | 'f' | 'r' | '\\\"' | '\\'' | '\\\\' )
    	    {
    	        MATCHC('\\');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESC_SEQEx;
    	        }


    	        if ( LA(1) == '"' || LA(1) == '\'' || LA(1) == '\\' || LA(1) == 'b' || LA(1) == 'f' || LA(1) == 'n' || LA(1) == 'r' || LA(1) == 't' )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleESC_SEQEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:519:9: UNICODE_ESC
    	    {
    	        /* 519:9: UNICODE_ESC */
    	        mUNICODE_ESC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESC_SEQEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:520:9: OCTAL_ESC
    	    {
    	        /* 520:9: OCTAL_ESC */
    	        mOCTAL_ESC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleESC_SEQEx;
    	        }



    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleESC_SEQEx; /* Prevent compiler warnings */
    ruleESC_SEQEx: ;

}
// $ANTLR end ESC_SEQ

//   Comes from: 525:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start OCTAL_ESC
 *
 * Looks to match the characters the constitute the token OCTAL_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mOCTAL_ESC(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;


    {
        //  F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:525:5: ( '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) ( '0' .. '7' ) | '\\\\' ( '0' .. '7' ) )

        ANTLR3_UINT32 alt19;

        alt19=3;

        switch ( LA(1) )
        {
        case '\\':
        	{
        		switch ( LA(2) )
        		{
        		case '0':
        		case '1':
        		case '2':
        		case '3':
        			{
        				switch ( LA(3) )
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						switch ( LA(4) )
        						{
        						case '0':
        						case '1':
        						case '2':
        						case '3':
        						case '4':
        						case '5':
        						case '6':
        						case '7':
        							{
        								alt19=1;
        							}
        						    break;

        						default:
        						    alt19=2;
        						}

        					}
        				    break;

        				default:
        				    alt19=3;
        				}

        			}
        		    break;
        		case '4':
        		case '5':
        		case '6':
        		case '7':
        			{
        				switch ( LA(3) )
        				{
        				case '0':
        				case '1':
        				case '2':
        				case '3':
        				case '4':
        				case '5':
        				case '6':
        				case '7':
        					{
        						alt19=2;
        					}
        				    break;

        				default:
        				    alt19=3;
        				}

        			}
        		    break;

        		default:
        		    CONSTRUCTEX();
        		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        		    EXCEPTION->message      = (void *)"";
        		    EXCEPTION->decisionNum  = 19;
        		    EXCEPTION->state        = 1;


        		    goto ruleOCTAL_ESCEx;

        		}

        	}
            break;

        default:
            CONSTRUCTEX();
            EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            EXCEPTION->message      = (void *)"";
            EXCEPTION->decisionNum  = 19;
            EXCEPTION->state        = 0;


            goto ruleOCTAL_ESCEx;

        }

        switch (alt19)
        {
    	case 1:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:525:9: '\\\\' ( '0' .. '3' ) ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCEx;
    	        }


    	        if ( ((LA(1) >= '0') && (LA(1) <= '3')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleOCTAL_ESCEx;
    	        }


    	        if ( ((LA(1) >= '0') && (LA(1) <= '7')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleOCTAL_ESCEx;
    	        }


    	        if ( ((LA(1) >= '0') && (LA(1) <= '7')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleOCTAL_ESCEx;
    	        }


    	    }
    	    break;
    	case 2:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:526:9: '\\\\' ( '0' .. '7' ) ( '0' .. '7' )
    	    {
    	        MATCHC('\\');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCEx;
    	        }


    	        if ( ((LA(1) >= '0') && (LA(1) <= '7')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleOCTAL_ESCEx;
    	        }


    	        if ( ((LA(1) >= '0') && (LA(1) <= '7')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleOCTAL_ESCEx;
    	        }


    	    }
    	    break;
    	case 3:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:527:9: '\\\\' ( '0' .. '7' )
    	    {
    	        MATCHC('\\');
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleOCTAL_ESCEx;
    	        }


    	        if ( ((LA(1) >= '0') && (LA(1) <= '7')) )
    	        {
    	            CONSUME();
    	        }
    	        else
    	        {
    	            CONSTRUCTEX();
    	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
    	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

    	            LRECOVER();
    	            goto ruleOCTAL_ESCEx;
    	        }


    	    }
    	    break;

        }
    }

    // This is where rules clean up and exit
    //
    goto ruleOCTAL_ESCEx; /* Prevent compiler warnings */
    ruleOCTAL_ESCEx: ;

}
// $ANTLR end OCTAL_ESC

//   Comes from: 532:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start UNICODE_ESC
 *
 * Looks to match the characters the constitute the token UNICODE_ESC
 * from the attached input stream.
 *
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static ANTLR3_INLINE
void mUNICODE_ESC(pyasLexer ctx)
{
	ANTLR3_UINT32	_type;


    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:532:5: ( '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT )
    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:532:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT
    {
        MATCHC('\\');
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }


        MATCHC('u');
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }


        /* 532:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }



        /* 532:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }



        /* 532:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }



        /* 532:9: '\\\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT */
        mHEX_DIGIT(ctx );
        if  (HASEXCEPTION())
        {
            goto ruleUNICODE_ESCEx;
        }



    }


    // This is where rules clean up and exit
    //
    goto ruleUNICODE_ESCEx; /* Prevent compiler warnings */
    ruleUNICODE_ESCEx: ;

}
// $ANTLR end UNICODE_ESC

/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void
mTokens(pyasLexer ctx)
{
    {
        //  F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:8: ( T__116 | T__117 | T__118 | T__119 | T__120 | T__121 | T__122 | T__123 | T__124 | T__125 | T__126 | T__127 | T__128 | T_PACKAGE | USE | CLASS | INTRFACE | SUPER | THIS | EXTENDS | IMPL | NEW | INST_OF | T_ASSERT | PROPERTY | FOR | FOREACH | WHILE | DO | SWITCH | CASE | DEFAULT | BREAK | CONTINUE | RETURN | IF | ELSE | TRY | CATCH | FINALLY | THROW | LITNULL | LITTRUE | LITFALSE | AND | OR | MUL | DIV | REM | PLUS | MINUS | BITCOMPL | NOT | BITAND | BITOR | BITXOR | INCR | DECR | EQUAL | UNEQUAL | SEQUAL | SMALLER | GREATER | GEQUAL | SHIFTL | SHIFTR | T_CHAR | T_INT | T_REAL | T_STRING | T_BOOL | T_VOID | STATIC | FINAL | ABSTRACT | NATIVE | SYNC | PUBLIC | PROT | PRIVATE | SEP | ID | INT | FLOAT | WHITESPACE | STRING | CHAR | COMMENT | LINE_COMMENT )

        ANTLR3_UINT32 alt20;

        alt20=89;

        alt20 = cdfa20.predict(ctx, RECOGNIZER, ISTREAM, &cdfa20);
        if  (HASEXCEPTION())
        {
            goto ruleTokensEx;
        }

        switch (alt20)
        {
    	case 1:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:10: T__116
    	    {
    	        /* 1:10: T__116 */
    	        mT__116(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 2:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:17: T__117
    	    {
    	        /* 1:17: T__117 */
    	        mT__117(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 3:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:24: T__118
    	    {
    	        /* 1:24: T__118 */
    	        mT__118(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 4:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:31: T__119
    	    {
    	        /* 1:31: T__119 */
    	        mT__119(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 5:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:38: T__120
    	    {
    	        /* 1:38: T__120 */
    	        mT__120(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 6:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:45: T__121
    	    {
    	        /* 1:45: T__121 */
    	        mT__121(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 7:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:52: T__122
    	    {
    	        /* 1:52: T__122 */
    	        mT__122(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 8:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:59: T__123
    	    {
    	        /* 1:59: T__123 */
    	        mT__123(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 9:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:66: T__124
    	    {
    	        /* 1:66: T__124 */
    	        mT__124(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 10:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:73: T__125
    	    {
    	        /* 1:73: T__125 */
    	        mT__125(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 11:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:80: T__126
    	    {
    	        /* 1:80: T__126 */
    	        mT__126(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 12:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:87: T__127
    	    {
    	        /* 1:87: T__127 */
    	        mT__127(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 13:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:94: T__128
    	    {
    	        /* 1:94: T__128 */
    	        mT__128(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 14:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:101: T_PACKAGE
    	    {
    	        /* 1:101: T_PACKAGE */
    	        mT_PACKAGE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 15:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:111: USE
    	    {
    	        /* 1:111: USE */
    	        mUSE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 16:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:115: CLASS
    	    {
    	        /* 1:115: CLASS */
    	        mCLASS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 17:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:121: INTRFACE
    	    {
    	        /* 1:121: INTRFACE */
    	        mINTRFACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 18:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:130: SUPER
    	    {
    	        /* 1:130: SUPER */
    	        mSUPER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 19:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:136: THIS
    	    {
    	        /* 1:136: THIS */
    	        mTHIS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 20:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:141: EXTENDS
    	    {
    	        /* 1:141: EXTENDS */
    	        mEXTENDS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 21:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:149: IMPL
    	    {
    	        /* 1:149: IMPL */
    	        mIMPL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 22:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:154: NEW
    	    {
    	        /* 1:154: NEW */
    	        mNEW(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 23:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:158: INST_OF
    	    {
    	        /* 1:158: INST_OF */
    	        mINST_OF(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 24:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:166: T_ASSERT
    	    {
    	        /* 1:166: T_ASSERT */
    	        mT_ASSERT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 25:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:175: PROPERTY
    	    {
    	        /* 1:175: PROPERTY */
    	        mPROPERTY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 26:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:184: FOR
    	    {
    	        /* 1:184: FOR */
    	        mFOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 27:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:188: FOREACH
    	    {
    	        /* 1:188: FOREACH */
    	        mFOREACH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 28:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:196: WHILE
    	    {
    	        /* 1:196: WHILE */
    	        mWHILE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 29:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:202: DO
    	    {
    	        /* 1:202: DO */
    	        mDO(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 30:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:205: SWITCH
    	    {
    	        /* 1:205: SWITCH */
    	        mSWITCH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 31:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:212: CASE
    	    {
    	        /* 1:212: CASE */
    	        mCASE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 32:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:217: DEFAULT
    	    {
    	        /* 1:217: DEFAULT */
    	        mDEFAULT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 33:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:225: BREAK
    	    {
    	        /* 1:225: BREAK */
    	        mBREAK(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 34:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:231: CONTINUE
    	    {
    	        /* 1:231: CONTINUE */
    	        mCONTINUE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 35:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:240: RETURN
    	    {
    	        /* 1:240: RETURN */
    	        mRETURN(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 36:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:247: IF
    	    {
    	        /* 1:247: IF */
    	        mIF(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 37:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:250: ELSE
    	    {
    	        /* 1:250: ELSE */
    	        mELSE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 38:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:255: TRY
    	    {
    	        /* 1:255: TRY */
    	        mTRY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 39:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:259: CATCH
    	    {
    	        /* 1:259: CATCH */
    	        mCATCH(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 40:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:265: FINALLY
    	    {
    	        /* 1:265: FINALLY */
    	        mFINALLY(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 41:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:273: THROW
    	    {
    	        /* 1:273: THROW */
    	        mTHROW(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 42:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:279: LITNULL
    	    {
    	        /* 1:279: LITNULL */
    	        mLITNULL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 43:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:287: LITTRUE
    	    {
    	        /* 1:287: LITTRUE */
    	        mLITTRUE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 44:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:295: LITFALSE
    	    {
    	        /* 1:295: LITFALSE */
    	        mLITFALSE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 45:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:304: AND
    	    {
    	        /* 1:304: AND */
    	        mAND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 46:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:308: OR
    	    {
    	        /* 1:308: OR */
    	        mOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 47:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:311: MUL
    	    {
    	        /* 1:311: MUL */
    	        mMUL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 48:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:315: DIV
    	    {
    	        /* 1:315: DIV */
    	        mDIV(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 49:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:319: REM
    	    {
    	        /* 1:319: REM */
    	        mREM(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 50:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:323: PLUS
    	    {
    	        /* 1:323: PLUS */
    	        mPLUS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 51:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:328: MINUS
    	    {
    	        /* 1:328: MINUS */
    	        mMINUS(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 52:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:334: BITCOMPL
    	    {
    	        /* 1:334: BITCOMPL */
    	        mBITCOMPL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 53:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:343: NOT
    	    {
    	        /* 1:343: NOT */
    	        mNOT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 54:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:347: BITAND
    	    {
    	        /* 1:347: BITAND */
    	        mBITAND(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 55:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:354: BITOR
    	    {
    	        /* 1:354: BITOR */
    	        mBITOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 56:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:360: BITXOR
    	    {
    	        /* 1:360: BITXOR */
    	        mBITXOR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 57:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:367: INCR
    	    {
    	        /* 1:367: INCR */
    	        mINCR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 58:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:372: DECR
    	    {
    	        /* 1:372: DECR */
    	        mDECR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 59:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:377: EQUAL
    	    {
    	        /* 1:377: EQUAL */
    	        mEQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 60:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:383: UNEQUAL
    	    {
    	        /* 1:383: UNEQUAL */
    	        mUNEQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 61:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:391: SEQUAL
    	    {
    	        /* 1:391: SEQUAL */
    	        mSEQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 62:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:398: SMALLER
    	    {
    	        /* 1:398: SMALLER */
    	        mSMALLER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 63:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:406: GREATER
    	    {
    	        /* 1:406: GREATER */
    	        mGREATER(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 64:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:414: GEQUAL
    	    {
    	        /* 1:414: GEQUAL */
    	        mGEQUAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 65:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:421: SHIFTL
    	    {
    	        /* 1:421: SHIFTL */
    	        mSHIFTL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 66:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:428: SHIFTR
    	    {
    	        /* 1:428: SHIFTR */
    	        mSHIFTR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 67:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:435: T_CHAR
    	    {
    	        /* 1:435: T_CHAR */
    	        mT_CHAR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 68:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:442: T_INT
    	    {
    	        /* 1:442: T_INT */
    	        mT_INT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 69:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:448: T_REAL
    	    {
    	        /* 1:448: T_REAL */
    	        mT_REAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 70:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:455: T_STRING
    	    {
    	        /* 1:455: T_STRING */
    	        mT_STRING(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 71:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:464: T_BOOL
    	    {
    	        /* 1:464: T_BOOL */
    	        mT_BOOL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 72:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:471: T_VOID
    	    {
    	        /* 1:471: T_VOID */
    	        mT_VOID(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 73:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:478: STATIC
    	    {
    	        /* 1:478: STATIC */
    	        mSTATIC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 74:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:485: FINAL
    	    {
    	        /* 1:485: FINAL */
    	        mFINAL(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 75:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:491: ABSTRACT
    	    {
    	        /* 1:491: ABSTRACT */
    	        mABSTRACT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 76:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:500: NATIVE
    	    {
    	        /* 1:500: NATIVE */
    	        mNATIVE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 77:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:507: SYNC
    	    {
    	        /* 1:507: SYNC */
    	        mSYNC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 78:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:512: PUBLIC
    	    {
    	        /* 1:512: PUBLIC */
    	        mPUBLIC(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 79:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:519: PROT
    	    {
    	        /* 1:519: PROT */
    	        mPROT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 80:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:524: PRIVATE
    	    {
    	        /* 1:524: PRIVATE */
    	        mPRIVATE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 81:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:532: SEP
    	    {
    	        /* 1:532: SEP */
    	        mSEP(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 82:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:536: ID
    	    {
    	        /* 1:536: ID */
    	        mID(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 83:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:539: INT
    	    {
    	        /* 1:539: INT */
    	        mINT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 84:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:543: FLOAT
    	    {
    	        /* 1:543: FLOAT */
    	        mFLOAT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 85:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:549: WHITESPACE
    	    {
    	        /* 1:549: WHITESPACE */
    	        mWHITESPACE(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 86:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:560: STRING
    	    {
    	        /* 1:560: STRING */
    	        mSTRING(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 87:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:567: CHAR
    	    {
    	        /* 1:567: CHAR */
    	        mCHAR(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 88:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:572: COMMENT
    	    {
    	        /* 1:572: COMMENT */
    	        mCOMMENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;
    	case 89:
    	    // F:\\Devel\\crafter2d\\tools\\yasc\\yas.g:1:580: LINE_COMMENT
    	    {
    	        /* 1:580: LINE_COMMENT */
    	        mLINE_COMMENT(ctx );
    	        if  (HASEXCEPTION())
    	        {
    	            goto ruleTokensEx;
    	        }



    	    }
    	    break;

        }
    }


    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
/* End of Lexer code
 * ================================================
 * ================================================
 */


/* End of code
 * =============================================================================
 */
